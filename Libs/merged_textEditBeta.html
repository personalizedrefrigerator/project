
<!DOCTYPE html>
<html style = "padding: 0px;">
<head>
    <meta name="viewport" content="width=device-width,height=device-height,initial-scale=1.0,min-scale=1.0,max-scale=1.0"/>
    <title>Code Edit</title>


<!-- Inserted File. "style.css". -->
<style>
/* FILE READ ERROR */
</style>


    <style>
            #mainCanvas
            {

            }

            #editControl
            {
                width: 95vw;
                height: 50vh;
            }

            body
            {
                background-color: black;
                color: white;
                padding-left: 0px;
            }
            
            textarea
            {
                background-color: #007777;
                color: white;
                
                border-radius: 3px;
            }
        </style>
</head>
    <body>
    <!-- Include Libraries -->

<!-- Inserted file  "Keyboard.js" encoding = "utf-8". -->
<script>
"use strict";

function Key(name, x, y, w, h, command)
{
    this.command = command || function () {};
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.name = name;

    var lastClickPoint = undefined;

    var me = this;

    this.checkCollision = function(point)
    {
        return (point.x > me.x && point.x < me.x + me.w && point.y > me.y && point.y < me.y + me.h);
    };

    this.handleClick = function(point)
    {
        lastClickPoint = point;

        if (me.checkCollision(point))
        {
            me.command();
        }
    };

    this.getAndUpdateWidth = function(ctx)
    {
        var width = ctx.measureText(me.name).width + 24;
        me.w = width;

        return width;
    };

    this.render = function(ctx)
    {
        ctx.beginPath();
        ctx.save();
        if (lastClickPoint && me.checkCollision(lastClickPoint))
        {
            ctx.fillStyle = "#0055ee";
        }
        else
        {
            ctx.fillStyle = "black";
        }

        ctx.strokeStyle = "white";
        ctx.rect(me.x, me.y, me.w, me.h);

        ctx.fill();
        ctx.stroke();

        ctx.textBaseline = "center";
        ctx.textAlign = "center";

        ctx.fillStyle = "white";
        ctx.fillText(me.name, me.x + me.w / 2, me.y + me.h / 2);
        ctx.restore();
    };
}

var LEFT_ARROW = "‚óÄÔ∏è";
var RIGHT_ARROW = "‚ñ∂Ô∏è";

function Keyboard(ctx, keyPressed)
{
    var me = this;
    this.onkeypress = keyPressed;
    this.ctx = ctx;
    var emojiStart = "‚óÄÔ∏è".charAt(0);
    this.keyChars = ["1‚ñ™2‚ñ™3‚ñ™4‚ñ™5‚ñ™6‚ñ™7‚ñ™8‚ñ™9‚ñ™0‚ñ™-‚ñ™+", "q‚ñ™w‚ñ™e‚ñ™r‚ñ™t‚ñ™y‚ñ™u‚ñ™i‚ñ™o‚ñ™p‚ñ™,‚ñ™‚è™", "üî†‚ñ™a‚ñ™s‚ñ™d‚ñ™f‚ñ™g‚ñ™h‚ñ™j‚ñ™k‚ñ™l‚ñ™‚¨ÜÔ∏è", "‚óÄÔ∏è‚ñ™z‚ñ™x‚ñ™c‚ñ™v‚ñ™b‚ñ™n‚ñ™m‚ñ™.‚ñ™;‚ñ™‚ñ∂Ô∏è", "üîº‚ñ™<‚ñ™=‚ñ™_SPACE_‚ñ™{‚ñ™}‚ñ™>‚ñ™/‚ñ™üîΩ‚ñ™‚è¨",
    "\'‚ñ™\"‚ñ™;‚ñ™:‚ñ™_‚ñ™[‚ñ™]‚ñ™&&‚ñ™||‚ñ™(‚ñ™)",
"üíæ‚ñ™üìÇ‚ñ™‚úÇÔ∏è‚ñ™üìú‚ñ™üìã‚ñ™üìå‚ñ™‚Ñπ‚ñ™‚öú‚ñ™üöò"];
    this.shiftKeyChars = ["!‚ñ™@‚ñ™#‚ñ™$‚ñ™%‚ñ™^‚ñ™~‚ñ™\`‚ñ™*‚ñ™_‚ñ™(‚ñ™)", "q‚ñ™w‚ñ™e‚ñ™r‚ñ™t‚ñ™y‚ñ™u‚ñ™i‚ñ™o‚ñ™p‚ñ™:‚ñ™‚è™", "üî°‚ñ™a‚ñ™s‚ñ™d‚ñ™f‚ñ™g‚ñ™h‚ñ™j‚ñ™k‚ñ™l‚ñ™‚¨ÜÔ∏è", "‚óÄÔ∏è‚ñ™z‚ñ™x‚ñ™c‚ñ™v‚ñ™b‚ñ™n‚ñ™m‚ñ™?‚ñ™\\‚ñ™‚ñ∂Ô∏è", "üîº‚ñ™\"‚ñ™'‚ñ™_SPACE_‚ñ™[‚ñ™]‚ñ™&‚ñ™|‚ñ™üîΩ‚ñ™‚è¨",
    "//‚ñ™/*‚ñ™*/‚ñ™=>‚ñ™}‚ñ™[‚ñ™]‚ñ™~‚ñ™*‚ñ™(‚ñ™)",
"üóÇÔ∏è‚ñ™‚öôÔ∏è‚ñ™‚úÇÔ∏è‚ñ™üìú‚ñ™üìã‚ñ™üìå‚ñ™‚ûñ‚ñ™‚ûï‚ñ™üîé"];

    for (var i = 0; i < this.shiftKeyChars.length; i++)
    {
        this.shiftKeyChars[i] = this.shiftKeyChars[i].toUpperCase();
    }

    this.x = 0;
    this.y = 0;
    this.maxX = 0;
    this.maxY = 0;
    this.keys = [];
    this.shiftKeys = [];

    var font = "12pt Serif";

    me.ctx.font = font;

    var keyH = this.ctx.measureText("W....").width;

    this.shiftPressed = false;
    this.capsLock = false;

    this.toggleCaps = function()
    {
        me.capsLock = !me.capsLock;
        me.shiftPressed = me.capsLock;
    };

    this.loadKeys = function(keyChars, keys)
    {
        var x = me.x;
        var y = me.y;

        var addKey = function(name)
        {
            var key = new Key(name, x, y, 20, keyH, function()
            {
                if (name == "‚¨ÜÔ∏è")
                {
                    me.toggleCaps();
                }
                else if (name === "üî†")
                {
                    me.shiftPressed = true;
                }
                else if (name === "üî°")
                {
                    me.shiftPressed = false;
                }
                else
                {
                    me.onkeypress(name);

                    if (!me.capsLock)
                    {
                        me.shiftPressed = false;
                    }
                }
            });

            x += key.getAndUpdateWidth(me.ctx);

            keys.push(key);
        };

        var row;
        var currentChar;

        for (var i = 0; i < keyChars.length; i++)
        {
            row = keyChars[i].split("‚ñ™");

            for (var j = 0; j < row.length; j++)
            {
                currentChar = row[j];



                addKey(currentChar);

            }

            if (x > me.maxX + 1)
            {
                me.maxX = x + 1;
            }

            y += keyH + 3;
            x = me.x;
        }

        if (y > me.maxY + 1)
        {
            me.maxY = y + 1;
        }
    };

    this.handleClick = function(point)
    {
        var keys = me.shiftPressed ? me.shiftKeys : me.keys;

        for (var i = 0; i < keys.length; i++)
        {
            keys[i].handleClick(point);
        }
    };

    this.render = function()
    {
        me.ctx.clearRect(me.x, me.y, me.maxX, me.maxY);
        me.ctx.font = font;

        var keys = me.shiftPressed ? me.shiftKeys : me.keys;

        for (var i = 0; i < keys.length; i++)
        {
            keys[i].render(me.ctx);
        }
    };

    this.loadKeys(me.keyChars, me.keys);
    this.loadKeys(me.shiftKeyChars, me.shiftKeys);
}
</script>


<!-- Inserted file  "Point.js" encoding = "utf-8". -->
<script>
"use strict";


// A simple Point class.
function Point(x, y, z)
{
    this.x = x;
    this.y = y;
    this.z = z || 0;
    
    this.transformBy = function(matrix)
    {
        var arrayToTransform = [this.x, this.y, this.z];
        
        if (matrix.getWidth() === matrix.getHeight() && matrix.getWidth() === 4)
        {
            arrayToTransform.push(1);
        }
        
        MatHelper.transformPoint(arrayToTransform, matrix);
        
        this.x = arrayToTransform[0];
        this.y = arrayToTransform[1];
        this.z = arrayToTransform[2];
    };
    
    // Returns a copy of this object. Subclasses
    //should override this.
    this.copy = function()
    {
        var result = new Point(this.x, this.y, this.z);
        
        return result;
    };
    
    // Returns a rounded copy of the point, rounded to 
    //the specified number of decimal places.
    this.asRounded = function(decimalPlaces)
    {
        var result = this.copy();
        
        var multiplier = Math.pow(10, decimalPlaces);
        
        result.x = Math.floor(this.x * multiplier) / multiplier;
        result.y = Math.floor(this.y * multiplier) / multiplier;
        result.z = Math.floor(this.z * multiplier) / multiplier;
        
        return result;
    };

    this.toArray = function()
    {
        return [this.x, this.y, this.z];
    };
    
    this.toString = function()
    {
        return "(" + this.x + ", " + this.y + ", " + this.z + ")";
    };
}

</script>


<!-- Inserted file  "MathHelper.js" encoding = "utf-8". -->
<script>
"use strict";

var MathHelper = {};

MathHelper.distance2D = function(point1, point2)
{
    return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
};

</script>


<!-- Inserted file  "HighlightSchemes.js" encoding = "utf-8". -->
<script>
"use strict";

function BashHighlightScheme(originalHighlighter)
{
    this.id = "BashHighlight";

    this.labelMap =
    {
        "if": "#cc33cc",
        "else": "#cc33cc"
    };

    this.labelMap[SyntaxHelper.COMMENT] = "green";
    this.labelMap[SyntaxHelper.STRING] = "yellow";
    this.labelMap[SyntaxHelper.NUMBER_START] = "pink";
    this.labelMap[SyntaxHelper.NUMBER_STOP] = "pink";
    this.labelMap[SyntaxHelper.END_SCRIPT] = "#44ffff"; // End script.


    this.labelSearchSeparators =
    {
    };

    this.labelSearchSeparators[SyntaxHelper.NUMBER_START] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators[SyntaxHelper.NUMBER_STOP] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators[SyntaxHelper.STRING] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators[SyntaxHelper.COMMENT] = SyntaxHelper.SEARCH_ALL;

    this.labelSearchRegexes =
    {
        start:
        {
        },
        end:
        {
        }
    };

    this.labelExtensions =
    {
        start: {},
        end: {}
    };

    this.labelSearchRegexes.start[SyntaxHelper.COMMENT] = new RegExp("\\\#", "g");
    this.labelSearchRegexes.start[SyntaxHelper.STRING] = new RegExp("[\\\"\\\']", "g");
    // this.labelSearchRegexes.start[SyntaxHelper.END_SCRIPT] = new RegExp("\\<\\w*/\\w*script\\w*\\>");

    this.labelSearchRegexes.end[SyntaxHelper.NUMBER_START] = SyntaxHelper.regexps.NUMBER_START;
    this.labelSearchRegexes.end[SyntaxHelper.NUMBER_STOP] = SyntaxHelper.regexps.NUMBER_STOP;
    this.labelSearchRegexes.end[SyntaxHelper.STRING] = new RegExp("[\\\"\\\']", "g");


    this.labelSearchFunctions =
    {
        start: {},
        end: {}
    };

    this.multiLineLabels =
    {

    };

    this.highlightSchemeSpecificLabels =
    {

    };

    // this.transitionHighlighterLabels[SyntaxHelper.TRANSIT_HIGHLIGHT_BLOCK] = originalHighlighter;

    var addedLabels = {};
    this.labelPrecedence =
    [["COMMENT"]];

    // Add any un-recorded labels to the precedence list.
    for (var i = 0; i < this.labelPrecedence.length; i++)
    {
        if (typeof this.labelPrecedence[i] !== "object")
        {
            addedLabels[this.labelPrecedence[i]] = true;
        }
        else
        {
            for (var j = 0; j < this.labelPrecedence[i].length; j++)
            {
                addedLabels[this.labelPrecedence[i][j]] = true;
            }
        }
    }

    for (var label in this.labelMap)
    {
        if (!addedLabels[label])
        {
            this.labelPrecedence.push(label);

            addedLabels[label] = true;
        }
    }
}

function JavaHighlightScheme(originalHighlighter)
{
    this.id = "JavaHighlight";

    this.labelMap =
    {
        "if": "#ca33ca",
        "else": "#ca33ca",
        "void": "#ca40cc",
        "int": "#ca40cc",
        "long": "#ca40cc",
        "short": "#ca40cc",
        "char": "#ca40cc",
        "boolean": "#ca40cc",
        "{": "#00ffff",
        "}": "#00ffff",
        "(": "#00ffff",
        ")": "#00ffff",
        "[": "#00ffff",
        "]": "#00ffff",
        "==": "#00aabb",
        "===": "#00aabb",
        "!": "#00aabb",
        "=": "#00aabb",
        ">": "#00aabb",
        "<": "#00aabb",
        ">=": "#00aabb",
        "<=": "#00aabb",
        "%": "#00aabb",
        "+": "#00aabb",
        "-": "#00aabb",
        "*": "#00aabb",
        "/": "#00aabb",
        ";": "#00aabb",
        ",": "#c0aabb",
        ":": "#f0aabb",
        "&": "#00aabb",
        "|": "#00aabb",
        "do": "#ab00cd",
        "while": "#ab00cd",
        "for": "#ab00cd",
        "in": "#ab70cd",
        "false": "#abab00",
        "true": "#abab00",
        "null": "#00ff66",
        "this": "#00ffff",
        "const": "#ffee00",
        "return": "#ff6677",
        "switch": "#00ccff",
        "case": "#00ccff",
        "default": "#00ccff",
        "break": "#bb00ee",
        "new": "#bb00ee",
        "throw": "#ff6677",
        "try": "#aaffff",
        "instanceof": "#77ff77",
        "catch": "#aaffff",
        "finally": "#aaffff",
        "class": "#77ffaa",
        "public": "#aaffaa",
        "private": "#aaffaa",
        "protected": "#aaffaa",
        "interface": "#77ffaa",
        "extends": "#77ee99",
        "implements": "#77ee99",
        "static": "#77ee99",
        "volatile": "#77ee99",
        "search": "#eeddff",
        "indexOf": "#eeddff",
        "startsWith": "#eeddff",
        "endsWith": "#eeddff",
        "replace": "#eeddff",
        "Math": "#ffaaff",
        "String": "#aaaaff",
        "Double": "#aaaaff",
        "Boolean": "#aaaaff",
        "Character": "#aaaaff",
        "Integer": "#aaaaff",
        "Thread": "#aaaaff",
        "InetAddress": "#ccccff",
        "Collections": "#ccccff",
        "Comparator": "#ccccff",
        "Exception": "#ffaaaa",
        "log": "#eeaaee",
        "println": "#eeaaee",
        "System": "#eeddcc",
        "out": "#aaaaff",
        "err": "#aaaaff",
        "in": "#aaaaff",
        "ArrayList": "#ccaaff",
        "List": "#ccaaff",
        "StringBuilder": "#ddaaff",
        "Scanner": "#ddaaff",
        "toString": "#aaaaff",
        "final": "#ffcccc",
        "Map": "#ccaaff",
        "push": "#eeddff",
        "pop": "#eeddff",
        "substring": "#eeddff",
        "substr": "#eeddff",
        "size": "#77eecc",
        "@": "#ffaaaa",
        "import": "#cccc77",
        "package": "#cccc77",
        "toUpperCase": "#eeddff",
        "toLowerCase": "#eeddff",
        "throws": "#ff88ff"
    };


    this.labelMap[SyntaxHelper.COMMENT] = "green";
    this.labelMap[SyntaxHelper.COMMENT_MULTI_LINE] = "green";
    this.labelMap[SyntaxHelper.STRING] = "yellow";
    this.labelMap["CHAR"] = "orange";
    this.labelMap[SyntaxHelper.NUMBER_START] = "pink";
    this.labelMap[SyntaxHelper.NUMBER_STOP] = "pink";
    this.labelMap[SyntaxHelper.END_SCRIPT] = "#44ffff"; // End script.


    this.labelSearchSeparators =
    {
    };

    this.labelSearchSeparators[SyntaxHelper.NUMBER_START] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators[SyntaxHelper.NUMBER_STOP] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators[SyntaxHelper.STRING] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators["CHAR"] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators["@"] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators[SyntaxHelper.COMMENT] = SyntaxHelper.SEARCH_ALL;
    // this.labelSearchSeparators[SyntaxHelper.END_SCRIPT] = SyntaxHelper.SEARCH_ALL,
    this.labelSearchSeparators[SyntaxHelper.COMMENT_MULTI_LINE] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators["{"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["}"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["("] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators[")"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["["] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["]"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["!"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators[";"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["&"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["|"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators[","] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators[":"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["="] = SyntaxHelper.COMPARISON_SEARCH_SEPARATOR;
    this.labelSearchSeparators["=="] = SyntaxHelper.COMPARISON_SEARCH_SEPARATOR;
    this.labelSearchSeparators["==="] = SyntaxHelper.COMPARISON_SEARCH_SEPARATOR;
    this.labelSearchSeparators["=>"] = SyntaxHelper.COMPARISON_SEARCH_SEPARATOR;
    this.labelSearchSeparators[">="] = SyntaxHelper.COMPARISON_SEARCH_SEPARATOR;
    this.labelSearchSeparators["<="] = SyntaxHelper.COMPARISON_SEARCH_SEPARATOR;
    this.labelSearchSeparators[">"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["<"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["%"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["*"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["+"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["-"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["/"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;

    this.labelSearchRegexes =
    {
        start:
        {
        },
        end:
        {
        }
    };

    this.labelExtensions =
    {
        start: {},
        end: {}
    };

    
    this.labelSearchRegexes.start[SyntaxHelper.COMMENT_MULTI_LINE] = new RegExp("\\\/\\\*", "g");
    this.labelSearchRegexes.start[SyntaxHelper.COMMENT] = new RegExp("\\\/\\\/", "g");
    this.labelSearchRegexes.start[SyntaxHelper.STRING] = new RegExp("[\\\"]", "g");
    this.labelSearchRegexes.start["CHAR"] = new RegExp("[\\\']", "g");
    // this.labelSearchRegexes.start[SyntaxHelper.END_SCRIPT] = new RegExp("\\<\\w*/\\w*script\\w*\\>");

    this.labelSearchRegexes.end[SyntaxHelper.COMMENT_MULTI_LINE] = new RegExp("\\\*\\\/", "g");
    this.labelSearchRegexes.end[SyntaxHelper.STRING] = new RegExp("[\\\"]", "g");
    this.labelSearchRegexes.end["CHAR"] = new RegExp("[\\\']", "g");
    this.labelSearchRegexes.end["@"] = new RegExp("\\@\\w+", "g");
    this.labelSearchRegexes.end[SyntaxHelper.NUMBER_START] = SyntaxHelper.regexps.NUMBER_START;
    this.labelSearchRegexes.end[SyntaxHelper.NUMBER_STOP] = SyntaxHelper.regexps.NUMBER_STOP;



    this.labelSearchFunctions =
    {
        start: {},
        end: {}
    };

    this.multiLineLabels =
    {
        "LONG_QUOTE": true
    };

    this.multiLineLabels[SyntaxHelper.COMMENT_MULTI_LINE] = true;

    this.highlightSchemeSpecificLabels =
    {

    };

    // this.transitionHighlighterLabels[SyntaxHelper.TRANSIT_HIGHLIGHT_BLOCK] = originalHighlighter;

    var addedLabels = {};
    this.labelPrecedence =
    [["COMMENT", "QUOTE", "CHAR", SyntaxHelper.COMMENT_MULTI_LINE], [">", "=", "<"]];

    // Add any un-recorded labels to the precedence list.
    for (var i = 0; i < this.labelPrecedence.length; i++)
    {
        if (typeof this.labelPrecedence[i] !== "object")
        {
            addedLabels[this.labelPrecedence[i]] = true;
        }
        else
        {
            for (var j = 0; j < this.labelPrecedence[i].length; j++)
            {
                addedLabels[this.labelPrecedence[i][j]] = true;
            }
        }
    }

    for (var label in this.labelMap)
    {
        if (!addedLabels[label])
        {
            this.labelPrecedence.push(label);

            addedLabels[label] = true;
        }
    }
}


function JavaScriptHighlightScheme(originalHighlighter)
{
    this.id = "JavaScriptHighlight";

    this.labelMap =
    {
        "LONG_QUOTE": "red",
        "if": "#ca53ca",
        "else": "#ca53ca",
        "function": "#ca60cc",
        "{": "#30ffff",
        "}": "#30ffff",
        "==": "#70aabb",
        "===": "#70aabb",
        "!": "#70aabb",
        "=": "#70aabb",
        ">": "#70aabb",
        "<": "#70aabb",
        "%": "#70aabb",
        "+": "#70aabb",
        "-": "#70aabb",
        "*": "#70aabb",
        "/": "#70aabb",
        "do": "#ab00cd",
        "while": "#ab00cd",
        "for": "#ab00cd",
        "in": "#ab70cd",
        "false": "#abab00",
        "true": "#abab00",
        "null": "#00ff66",
        "undefined": "#bbbbdd",
        "=>": "#ea00ea",
        "this": "#00ffff",
        "let": "#ffaacc",
        "var": "#ffaadd",
        "const": "#ffee00",
        "return": "#ff6677",
        "switch": "#00ccff",
        "case": "#00ccff",
        "default": "#00ccff",
        "break": "#bb00ee",
        "new": "#bb00ee",
        "throw": "#ff6677",
        "try": "#aaffff",
        "typeof": "#77ff77",
        "createElement": "#eeffee",
        "catch": "#aaffff",
        "class": "#77ffaa",
        "get": "#77ee99",
        "extends": "#77ee99",
        "__constructor": "#77ee99",
        "async": "#aa66aa",
        "await": "#aa66aa",
        "document": "#bbffbb",
        "window": "#bbffbb",
        "alert": "#ffaabb",
        "confirm": "#ffaabb",
        "prompt": "#ffaabb",
        "innerHTML": "#ff7aaa",
        "outerHTML": "#ff7aaa",
        "search": "#eeddff",
        "indexOf": "#eeddff",
        "lastIndexOf": "#eeddff",
        "replace": "#eeddff",
        "Math": "#ffaaff",
        "innerText": "#ff7eaa",
        "me": "#aaffaa",
        "getContext": "#aaeeff",
        "style": "#ffeeff",
        ";": "#ffaaff",
        "save": "#a000ff",
        "restore": "#a000ff",
        "ctx": "#a060ff",
        "gl": "#a060ff",
        "continue": "#88bbcc",
        "delete": "#ff7799",
        "concat": "#aaffaa",
        "sort": "#aaffaa",
        "textContent": "#7affaa",
        "createElement": "#7affaa",
        "appendChild": "#7affaa",
        "script": "#ffccff",
        "removeChild": "#7affaa",
        "addEventListener": "#7affaa",
        "then": "#7aff99",
        "Promise": "#7aff99",
        "push": "#eeddff",
        "pop": "#eeddff",
        "substring": "#eeddff",
        "substr": "#eeddff",
        "splice": "#eeddff",
        "length": "#77eecc",
        "eval": "#ff7777",
        "JSON": "#aaffaa",
        "__proto__": "#ffaaaa",
        "prototype": "#aaaaff",
        "RegExp": "#aaaaff",
        "clientWidth": "#eeeeff",
        "clientHeight": "#eeeeff",
        "[": "#80aaff",
        "]": "#80aaff",
        "|": "#80aaff",
        "&": "#80aaff",
        "^": "#80aaff",
        "(": "#ffcece",
        ")": "#ffcece"
    };


    this.labelMap[SyntaxHelper.COMMENT] = "green";
    this.labelMap[SyntaxHelper.COMMENT_MULTI_LINE] = "green";
    this.labelMap[SyntaxHelper.STRING + "1"] = "yellow";
    this.labelMap[SyntaxHelper.STRING + "2"] = "yellow";
    this.labelMap[SyntaxHelper.NUMBER_START] = "pink";
    this.labelMap[SyntaxHelper.NUMBER_STOP] = "pink";
    this.labelMap[SyntaxHelper.END_SCRIPT] = "#44ffff"; // End script.


    this.labelSearchSeparators =
    {
    };

    this.labelSearchSeparators[SyntaxHelper.NUMBER_START] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators[SyntaxHelper.NUMBER_STOP] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators[SyntaxHelper.STRING + "1"] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators[SyntaxHelper.STRING + "2"] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators[SyntaxHelper.COMMENT] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators["__constructor"] = SyntaxHelper.SEARCH_ALL;
    // this.labelSearchSeparators[SyntaxHelper.END_SCRIPT] = SyntaxHelper.SEARCH_ALL,
    this.labelSearchSeparators[SyntaxHelper.COMMENT_MULTI_LINE] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators["LONG_QUOTE"] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators["{"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["}"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["("] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators[")"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["["] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["]"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["^"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["&"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["|"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["!"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators[";"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["="] = SyntaxHelper.COMPARISON_SEARCH_SEPARATOR;
    this.labelSearchSeparators["=="] = SyntaxHelper.COMPARISON_SEARCH_SEPARATOR;
    this.labelSearchSeparators["==="] = SyntaxHelper.COMPARISON_SEARCH_SEPARATOR;
    this.labelSearchSeparators["=>"] = SyntaxHelper.COMPARISON_SEARCH_SEPARATOR;
    this.labelSearchSeparators[">"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["<"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["%"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["*"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["+"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["-"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["/"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;

    this.labelSearchRegexes =
    {
        start:
        {
        },
        end:
        {
        }
    };

    this.labelExtensions =
    {
        start: {},
        end: {}
    };

    this.labelSearchRegexes.start[SyntaxHelper.COMMENT_MULTI_LINE] = new RegExp("\\\/\\\*", "g");
    this.labelSearchRegexes.start[SyntaxHelper.COMMENT] = new RegExp("\\\/\\\/", "g");
    this.labelSearchRegexes.start[SyntaxHelper.STRING + "1"] = new RegExp("[\\\"]", "g");
    this.labelSearchRegexes.start[SyntaxHelper.STRING + "2"] = new RegExp("[\\\']", "g");
    this.labelSearchRegexes.start["LONG_QUOTE"] = new RegExp("\\\`", "g");
    // this.labelSearchRegexes.start[SyntaxHelper.END_SCRIPT] = new RegExp("\\<\\w*/\\w*script\\w*\\>");

    this.labelSearchRegexes.end[SyntaxHelper.COMMENT_MULTI_LINE] = new RegExp("\\\*\\\/", "g");
    this.labelSearchRegexes.end[SyntaxHelper.STRING + "1"] = new RegExp("[\\\"]", "g");
    this.labelSearchRegexes.end[SyntaxHelper.STRING + "2"] = new RegExp("[\\\']", "g");
    this.labelSearchRegexes.end["LONG_QUOTE"] = this.labelSearchRegexes.start["LONG_QUOTE"];
    this.labelSearchRegexes.end["__constructor"] = new RegExp("constructor", "g");
    this.labelSearchRegexes.end[SyntaxHelper.NUMBER_START] = SyntaxHelper.regexps.NUMBER_START;
    this.labelSearchRegexes.end[SyntaxHelper.NUMBER_STOP] = SyntaxHelper.regexps.NUMBER_STOP;


    this.labelSearchFunctions =
    {
        start: {},
        end: {}
    };

    this.multiLineLabels =
    {
        "LONG_QUOTE": true
    };

    this.multiLineLabels[SyntaxHelper.COMMENT_MULTI_LINE] = true;

    this.highlightSchemeSpecificLabels =
    {

    };

    // this.transitionHighlighterLabels[SyntaxHelper.TRANSIT_HIGHLIGHT_BLOCK] = originalHighlighter;

    var addedLabels = {};
    this.labelPrecedence =
    [["COMMENT", "QUOTE2", "QUOTE1", "LONG_QUOTE", SyntaxHelper.COMMENT_MULTI_LINE], "=>", [">", "=", "<"]];

    // Add any un-recorded labels to the precedence list.
    for (var i = 0; i < this.labelPrecedence.length; i++)
    {
        if (typeof this.labelPrecedence[i] !== "object")
        {
            addedLabels[this.labelPrecedence[i]] = true;
        }
        else
        {
            for (var j = 0; j < this.labelPrecedence[i].length; j++)
            {
                addedLabels[this.labelPrecedence[i][j]] = true;
            }
        }
    }

    for (var label in this.labelMap)
    {
        if (!addedLabels[label])
        {
            this.labelPrecedence.push(label);

            addedLabels[label] = true;
        }
    }
}

function CSSSyntaxHighlightScheme()
{
    this.id = "CSSHighlight";

    this.labelMap =
    {
        "#": "#00ff77",
        ".": "#00ff77",
        "@": "#00ff77",
        "body": "#00bbbb",
        "html": "#00bbbb",
        "p": "#00bbbb",
        "br": "#00bbbb",
        "button": "#9077eb",
        "hr": "#9077eb",
        "input": "#9077eb",
        "h1": "#9077eb",
        "textarea": "#9077eb",
        "center": "#9077eb",
        "a": "#9077eb",
        "div": "#9077eb",
        "ol": "#9077eb",
        "li": "#9077eb",
        "tr": "#9077eb",
        "td": "#9077eb",
        "thead": "#9077eb",
        "tbody": "#9077eb",
        "table": "#9077eb",
        "background": "#bb00bb",
        "rgba": "#aa4488",
        "color": "#bb00bb",
        "gradient": "#aa4488",
        "linear": "#aa4488",
        "radial": "#aa4488",
        "url": "#ccccdd",
        "border": "#bb00bb",
        "radius": "#bb00bb",
        "outline": "#bb00bb",
        "position": "#ffff00",
        "display": "#ffff00",
        "top": "#bb00bb",
        "left": "#bb00bb",
        "bottom": "#bb00bb",
        "right": "#bb00bb",
        "padding": "#bb00bb",
        "margin": "#bb00bb",
        "none": "#00ffaa",
        "auto": "#00ffaa",
        "block": "#00ffaa",
        "absolute": "#00ffaa",
        "flex": "#00ffaa",
        "grow": "#00ffaa",
        "style": "#00ffaa",
        "width": "#bb00bb",
        "height": "#bb00bb",
        "min": "#bb00bb",
        "max": "#bb00bb",
        "transform": "#cc04cc",
        "rotate": "#00cccc",
        "scale": "#00cccc",
        "font": "#bb00bb",
        "box-shadow": "#00cccc",
        "text-shadow": "#00cccc",
        "cursor": "#00cccc",
        "filter": "#00cccc",
        "size": "#bb00bb",
        "image": "#bb00bb",
        "matrix": "#00cccc",
        "overflow-x": "#bb00bb",
        "overflow-y": "#bb00bb",
        "animation": "#bb00bb",
        "transition": "#bb00bb",
        "NUMBER": "#00ff77",
        "text": "#bb00bb",
        "line": "#bb00bb",
        "align": "#bb00bb",
        "indent": "#bb00bb",
        "red": "#ffaaaa",
        "green": "#aaffaa",
        "blue": "#aaaaff",
        "orange": "#ffaa44",
        "purple": "#ffaaff",
        "gray": "#cccccc",
        "brown": "#aaaa77",
        "black": "#bbbbcc",
        "yellow": "#ffffaa",
        "pink": "#ffaaff",
        "violet": "#ff00ff"
    };

    this.labelMap[SyntaxHelper.COMMENT] = "#ff50ff";

    this.labelSearchSeparators =
    {
    };

    this.labelSearchSeparators["#"] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators["."] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators["@"] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators["NUMBER"] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators[SyntaxHelper.COMMENT] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators["h1"] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators["box-shadow"] = SyntaxHelper.CSS_LABEL_SEPARATORS;
    this.labelSearchSeparators["text-shadow"] = SyntaxHelper.CSS_LABEL_SEPARATORS;
    this.labelSearchSeparators["overflow-x"] = SyntaxHelper.CSS_LABEL_SEPARATORS;
    this.labelSearchSeparators["overflow-y"] = SyntaxHelper.CSS_LABEL_SEPARATORS;

    this.labelSearchRegexes =
    {
        start:
        {
        },
        end:
        {
        }
    };

    //this.labelSearchRegexes.start["#"] = new RegExp("\\#\\w+", "g");
    this.labelSearchRegexes.start[SyntaxHelper.COMMENT] = new RegExp("\\/\\*", "g");

    this.labelSearchRegexes.end["#"] = new RegExp("\\#\\w+", "g");
    this.labelSearchRegexes.end["."] = new RegExp("\\.\\w+", "g");
    this.labelSearchRegexes.end["@"] = new RegExp("\\@\\w+", "g");
    this.labelSearchRegexes.end["h1"] = new RegExp("h[0-6]", "g");
    this.labelSearchRegexes.end["NUMBER"] = new RegExp("[0-9]", "g");

    this.labelSearchRegexes.end[SyntaxHelper.COMMENT] = new RegExp("\\*\\/", "g");

    this.labelExtensions =
    {
        start: {},
        end: {}
    };

    this.multiLineLabels =
    {

    };

    this.multiLineLabels[SyntaxHelper.COMMENT] = true;

    this.highlightSchemeSpecificLabels =
    {

    };

    var addedLabels = {};
    this.labelPrecedence =
    [SyntaxHelper.COMMENT];

    // Add any un-recorded labels to the precedence list.
    for (var i = 0; i < this.labelPrecedence.length; i++)
    {
        if (typeof this.labelPrecedence[i] !== "object")
        {
            addedLabels[this.labelPrecedence[i]] = true;
        }
        else
        {
            for (var j = 0; j < this.labelPrecedence[i].length; j++)
            {
                addedLabels[this.labelPrecedence[i][j]] = true;
            }
        }
    }

    for (var label in this.labelMap)
    {
        if (!addedLabels[label])
        {
            this.labelPrecedence.push(label);

            addedLabels[label] = true;
        }
    }
}

function HTMLSyntaxHighlightScheme()
{
    this.id = "htmlHighlight";

    this.labelMap =
    {
        "!": "#00aabb",
        "=": "#00aabb",
        "DOCTYPE": "#ff7700",
        "html": "#ff7700"
    };

    this.labelMap[SyntaxHelper.COMMENT_HTML] = "gray";
    this.labelMap[SyntaxHelper.STRING] = "yellow";
    this.labelMap[SyntaxHelper.SCRIPT_BLOCK] = "#44ffff";
    this.labelMap[SyntaxHelper.STYLE_BLOCK] = "#44ffff";
    this.labelMap["ELEMENT"] = "#ffcc00";

    this.labelSearchSeparators =
    {
    };

    this.labelSearchSeparators[SyntaxHelper.STRING] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators[SyntaxHelper.SCRIPT_BLOCK] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators[SyntaxHelper.STYLE_BLOCK] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators[SyntaxHelper.COMMENT_HTML] = SyntaxHelper.SEARCH_ALL;
    this.labelSearchSeparators["!"] = SyntaxHelper.SINGLE_CHAR_SEPARATOR;
    this.labelSearchSeparators["="] = SyntaxHelper.COMPARISON_SEARCH_SEPARATOR;
    this.labelSearchSeparators["ELEMENT"] = SyntaxHelper.SEARCH_ALL;

    this.labelSearchRegexes =
    {
        start:
        {
        },
        end:
        {
        }
    };

    this.labelSearchRegexes.start[SyntaxHelper.COMMENT_HTML] = new RegExp("\\<\\!\\-\\-", "g");
    this.labelSearchRegexes.start[SyntaxHelper.STRING] = new RegExp("[\\\"\\\']", "g");
    this.labelSearchRegexes.start[SyntaxHelper.SCRIPT_BLOCK] = new RegExp("\\<\\s*script\\s*(?:[type\\=text\\\ \\\/JavaScript\\\"\\']+)?\\s*\\>", "ig");
    this.labelSearchRegexes.start[SyntaxHelper.STYLE_BLOCK] = new RegExp("\\<\\s*style\\s*(?:[type\\=text\\\ \\\/css\\\"\\']+)?\\s*\\>", "ig");
    this.labelSearchRegexes.start["ELEMENT"] = new RegExp("[<]", "g");

    this.labelSearchRegexes.end[SyntaxHelper.SCRIPT_BLOCK] = new RegExp("\\<\\s*\\/\\s*script\\s*\\>", "ig");
    this.labelSearchRegexes.end[SyntaxHelper.STYLE_BLOCK] = new RegExp("\\<\\s*\\/\\s*style\\s*\\>", "ig");
    this.labelSearchRegexes.end[SyntaxHelper.STRING] = new RegExp("[\\\"\\\']", "g");
    this.labelSearchRegexes.end[SyntaxHelper.COMMENT_HTML] = new RegExp("\\-\\-\\>", "g");
    this.labelSearchRegexes.end["ELEMENT"] = new RegExp("[>]", "g");

    this.labelExtensions =
    {
        start: {},
        end: {}
    };

    this.labelExtensions.end["ELEMENT"] = 0;

    this.multiLineLabels =
    {

    };

    this.multiLineLabels[SyntaxHelper.COMMENT_HTML] = true;
    this.multiLineLabels[SyntaxHelper.SCRIPT_BLOCK] = true;
    this.multiLineLabels[SyntaxHelper.STYLE_BLOCK] = true;

    this.highlightSchemeSpecificLabels =
    {

    };

    this.highlightSchemeSpecificLabels[SyntaxHelper.SCRIPT_BLOCK] = new JavaScriptHighlightScheme(this);
    this.highlightSchemeSpecificLabels[SyntaxHelper.STYLE_BLOCK] = new CSSSyntaxHighlightScheme(this);

    var addedLabels = {};
    this.labelPrecedence =
    [[SyntaxHelper.SCRIPT_BLOCK, SyntaxHelper.STYLE_BLOCK, SyntaxHelper.COMMENT_HTML, SyntaxHelper.STRING], "ELEMENT"];

    // Add any un-recorded labels to the precedence list.
    for (var i = 0; i < this.labelPrecedence.length; i++)
    {
        if (typeof this.labelPrecedence[i] !== "object")
        {
            addedLabels[this.labelPrecedence[i]] = true;
        }
        else
        {
            for (var j = 0; j < this.labelPrecedence[i].length; j++)
            {
                addedLabels[this.labelPrecedence[i][j]] = true;
            }
        }
    }

    for (var label in this.labelMap)
    {
        if (!addedLabels[label])
        {
            this.labelPrecedence.push(label);

            addedLabels[label] = true;
        }
    }
}

</script>


<!-- Inserted file  "SyntaxHelper.js" encoding = "utf-8". -->
<script>

var SyntaxHelper =
{
    END_OF_LINE: -12,
    COMMENT: "COMMENT",
    COMMENT_MULTI_LINE: "COMMENT_MULTI_LINE",
    COMMENT_HTML: "COMMENT_HTML",
    STRING: "QUOTE",
    NUMBER_START: "NUMBER_START",
    NUMBER_STOP: "NUMBER_STOP",
    STANDARD_SEPARATORS: ">(<, \t*%:-+/!=.){}[];",
    CSS_LABEL_SEPARATORS: "[],{}; :\t",
    SEARCH_ALL: { all: true },
    SINGLE_CHAR_SEPARATOR: "",
    NUMBER_SEPARATORS: ">(<, \t*%/!=){}",
    COMPARISON_SEARCH_SEPARATOR: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890 \t[]()_?!",

    LABEL_SINGLE: "SINGLE_LABEL",
    LABEL_START: "START_LABEL",
    LABEL_END: "END_LABEL",
    LABEL_CONTINUED: "CONTINUED_LABEL",

    SCRIPT_BLOCK: "SCRIPT_BLOCK",
    STYLE_BLOCK: "STYLE_BLOCK"
};

SyntaxHelper.regexps =
{
    NUMBER_START: new RegExp("(?:^|[\\( \\t\\=\\/\\+\\-\\#\\;])\\d+(?:[\\. \\t\\=\\/\\+\\-\\#\\;\\)\\,]|$)", "g"),
    NUMBER_STOP: new RegExp("\\.\\d+(?:[\\. \\t\\=\\/\\+\\-\\#\\;\\)\\,]|$)", "g")
};

SyntaxHelper.highlighters = { "js": new JavaScriptHighlightScheme(), "css": new CSSSyntaxHighlightScheme(), "html": new HTMLSyntaxHighlightScheme(),
                    "sh": new BashHighlightScheme(),
                    "java": new JavaHighlightScheme() };

SyntaxHelper.fileExtensionToHighlighterMap =
{
    js: SyntaxHelper.highlighters.js,
    css: SyntaxHelper.highlighters.css,
    html: SyntaxHelper.highlighters.html,
    htm: SyntaxHelper.highlighters.html,
    sh: SyntaxHelper.highlighters.sh,
    java: SyntaxHelper.highlighters.java
};

SyntaxHelper.getStillOpenBrackets = function(text, 
        bracketOpenChar, bracketCloseChar, countOpenBefore,
        quoteChars, inQuote)
{
    var result = countOpenBefore || 0;
    var currentChar;
    
    var inQuote = inQuote || false;
    
    quoteChars = quoteChars || {};
    
    for (let i = 0; i < text.length; i++)
    {
        currentChar = text.charAt(i);
        
        if (currentChar === bracketOpenChar && !inQuote)
        {
            result ++;
        }
        else if (currentChar === bracketCloseChar && !inQuote)
        {
            result --;
        }
        else if (quoteChars[currentChar])
        {
            inQuote = !inQuote;
        }
    }
    
    return result;
};

function SyntaxChecker()
{
    const me = this;
    
    this.state = {};
    
    this.quoteChars =
    {
        "'": true,
        '\"': true,
        '`': true
    };
    
    this.navigationHelper =
    {
        levelCheckChars: [["[", "]"],
                          ["{", "}"],
                          ["(", ")"]],
                          
        // Note: THIS MUST BE CALLED FOR EVERY LINE,
        //in order of the line's number -- lineNo should
        //increase by 1 each call.       
        recordLevel: (state, text, lineNo) =>
        {
            if (!state.subZero)
            {
                state.subZero = {};
            }
            
            if (state.lastLineWithBracketCheck === lineNo)
            {
                console.log ("Error: state.lastLineWithBracketCheck === lineNo === " + lineNo);
                
                return;
            }
            
            state.lastLineWithBracketCheck = lineNo;
            
            var startLabel, endLabel;
        
            for (var i in me.navigationHelper.levelCheckChars)
            {
                startLabel = me.navigationHelper.levelCheckChars[i][0];
                endLabel = me.navigationHelper.levelCheckChars[i][1];
                
                if (state["openBrackets" + startLabel] === undefined)
                {
                    state["openBrackets" + startLabel] = [];
                }
                
                state["openBrackets" + startLabel][lineNo] = ( 
                  SyntaxHelper.getStillOpenBrackets(text, 
                    startLabel, 
                    endLabel, 
                    state["openBrackets" + startLabel][lineNo - 1] || 0,
                    me.quoteChars ));
                    
                state["openBrackets" + startLabel].length = lineNo + 1;
                    
                if (state["openBrackets" + startLabel] < 0)
                {
                    state.subZero[lineNo] = [startLabel, state["openBrackets"]];
                }
            }
        },
        
        getLastLineBelowLevel: (state, level, levelCheckChar) =>
        {
            var levelRecords = state["openBrackets" + levelCheckChar];
            
            for (let i = levelRecords.length - 1; i >= 0; i++)
            {
                if (levelRecords[i] < level)
                {
                    return i;
                }
            }
            
            return -1; // If -1 is returned, no lines were below
                       //the requested level.
        },
        
        getBracketsBelowOrAboveLevelOnLine: (state, lineNumber, level, belowLevel) =>
        {
            var currentGroupingCharacter, currentLevel;
            var count = {}; // Accumulates the number of open brackets on a specific line.
            
            // For/in for flexibility.
            for (var label in me.navigationHelper.levelCheckChars)
            {
                currentGroupingCharacter = me.navigationHelper.levelCheckChars[label][0];
                
                currentLevel = state["openBrackets" + currentGroupingCharacter][lineNumber];
                
                if (count[currentGroupingCharacter] === undefined)
                {
                    count[currentGroupingCharacter] = 0;
                }
                
                if (state["openBrackets" + currentGroupingCharacter][lineNumber] < level && belowLevel
                    || 
                    state["openBrackets" + currentGroupingCharacter][lineNumber] > level && !belowLevel)
                {
                    count[currentGroupingCharacter] = 1;
                }
            }
            
            return count;
        },
        
        getBracketsBelowLevelOnLine: (state, lineNumber, level) =>
        {
            return me.navigationHelper.getBracketsBelowOrAboveLevelOnLine(state, lineNumber, level, true);
        },
        
        getBracketsAboveLevelOnLine: (state, lineNumber, level) =>
        {
            return me.navigationHelper.getBracketsBelowOrAboveLevelOnLine(state, lineNumber, level, false);
        }
    };
    
    this.errorCheckers =
    {
        unendedString: (state, text) =>
        {
            var currentChar = "",
                lastChar    = "";
            var inSingleQuote = false;
            var inDoubleQuote = false;
            
            for (var i = 0; i < text.length; i++)
            {
                currentChar = text.charAt(i);
                
                if (currentChar === "'"
                    && lastChar !== '\\'
                     && !inDoubleQuote)
                {
                    inSingleQuote = !inSingleQuote;
                }
                else if (currentChar === '\"'
                    && lastChar !== '\\'
                    && !inSingleQuote)
                {
                    inDoubleQuote = !inDoubleQuote;
                }
                
                lastChar = currentChar;
            }
            
            return inSingleQuote || inDoubleQuote;
        },
        
        // Note that lineNo is the line number, where no
        //is a poor abbrievation for number. You might
        //want to rename this.
        bracketLevelError: (state, text, lineNo, isLastLine) =>
        {
            me.navigationHelper.recordLevel(state, text, lineNo);
            
            let message = undefined;
            
            // If any brackets have a level lesser than zero:
            var bracketsBelowZero = me.navigationHelper.getBracketsBelowLevelOnLine(state, lineNo, 0);
            
            if (JSON.stringify(bracketsBelowZero) != JSON.stringify(state.lastLineBelowZero || {}))
            {
                if (message === undefined)
                {
                    message = "";
                }
            
                var totalBelowZero = 0;
                
                for (var bracket in bracketsBelowZero)
                {
                    totalBelowZero += bracketsBelowZero[bracket];
                    
                    if (bracketsBelowZero[bracket] > 0)
                    {
                        message += "The bracket level for " + bracket + " is below zero. ";
                    }
                }
                
                state.lastLineBelowZero = bracketsBelowZero;
            }
            
            if (isLastLine)
            {
                var bracketsAboveZero = me.navigationHelper.getBracketsAboveLevelOnLine(state, lineNo, 0);
                
                var totalAboveZero = 0;
                
                for (var bracket in bracketsAboveZero)
                {
                    totalAboveZero += bracketsAboveZero[bracket];
                    
                    if (bracketsAboveZero[bracket])
                    {
                        message = message || "";
                        message += "Bracket " + bracket + " has no end. ";
                    }
                }
            }
            
            return message;
        }
    };
    
    this.checkFunctions =
    {
        "Line Level Check": me.errorCheckers.bracketLevelError
    };

    this.reset = function()
    {
        me.state = {};
        me.state.problems = [];
    };
    
    this.setBaseProblems = function(baseProblems)
    {
        me.state.problems = baseProblems;
    };

    this.checkLine = function(lineText, lineNumber, lastLine, lineLabels)
    {
        var currentMessage = undefined;
        
        if (lineText === undefined)
        {
            return;
        }
        
        for (var key in me.checkFunctions)
        {
            currentMessage = me.checkFunctions[key](me.state, lineText, lineNumber, lastLine || false);
            
            if (currentMessage)
            {
                me.state.problems.push(
                {
                    check: key,
                    lineNumber: lineNumber,
                    lineText: lineText,
                    message: currentMessage
                });
            }
        }
    };
    
    this.checkFinalLine = function(lineText, lineNumber, lineLabels)
    {
        me.checkLine(lineText, lineNumber, true);
    };
    
    this.getProblems = function()
    {
        return me.state.problems;
    };
}

SyntaxHelper.makeChecker = () =>
{
    return new SyntaxChecker();
};


function SyntaxSelector(initialHighlightScheme)
{
    const me = this;
    me.baseColor = "white";
    me.highlightScheme = initialHighlightScheme || (new HTMLSyntaxHighlightScheme());

    this.setDefaultHighlightScheme = function(key)
    {
        if (typeof (key) === "string")
        {
            if (key in SyntaxHelper.fileExtensionToHighlighterMap)
            {
                me.highlightScheme = SyntaxHelper.fileExtensionToHighlighterMap[key];
                return true;
            }
        }
        else if (typeof (key) === "object")
        {
            me.highlightScheme = key;

            return true;
        }

        return false;
    };

    this.getDefaultHighlighter = function()
    {
        return me.highlightScheme;
    };

    this.setDefaultHighlighter = function(key)
    {
        me.setDefaultHighlightScheme(key);
    };

    this.getBaseColor = function()
    {
        return me.baseColor;
    };

    /* Give only applicable labels. */
    this.getColor = function(labels)
    {
        let j, k, l, currentLabel, samePrecedenceLabels;

        let sortedLabels = getDepthSortedLabels(labels);

        /* Do any request a specific highlighter? */
        let isMissingDependency = me.getMissingDependencyCheck(labels);//, sortedLabels);
        let highlightScheme = me.getHighlightScheme(labels, isMissingDependency, sortedLabels);

        /* DANGER! This loop returns! */
        for (let i = 0; i < highlightScheme.labelPrecedence.length; i++)
        {
            /* If there are multiple labels with the same precedence,
            choose the one that started first. */
            if (typeof (highlightScheme.labelPrecedence[i]) === "object")
            {
                samePrecedenceLabels = [];
                for (j = 0; j < highlightScheme.labelPrecedence[i].length; j++)
                {
                    currentLabel = highlightScheme.labelPrecedence[i][j];

                    if (currentLabel in labels)
                    {
                        for (k = 0; k < labels[currentLabel].length; k++)
                        {
                            if (!isMissingDependency(labels[currentLabel][k]))
                            {
                                samePrecedenceLabels.push(labels[currentLabel][k]);
                            }
                        }
                    }
                }

                /* Sort the labels by which occurs first. */
                samePrecedenceLabels.sort(function(first, second)
                {
                    return first.startIndex - second.startIndex;
                });

                /* Choose the first, if any, that is applicable. */
                if (samePrecedenceLabels.length > 0)
                {
                    return highlightScheme.labelMap[samePrecedenceLabels[0].tagName];
                }
            }
            else /* Otherwise, if only one with the same precedence, */
            {
                currentLabel = highlightScheme.labelPrecedence[i];

                if (currentLabel in labels)
                {
                    let missingDependencyCount = 0;

                    for (l = 0; l < labels[currentLabel].length; l++)
                    {
                        if (isMissingDependency(labels[currentLabel][l]))
                        {
                            missingDependencyCount++;
                        }
                    }

                    if (missingDependencyCount !== labels[currentLabel].length)
                    {
                        return highlightScheme.labelMap[currentLabel];
                    }
                }
            }
        }

        /* No matching tags... */
        return me.getBaseColor();
    };

    this.getLabelIndicies = function(text, indexOffset, highlightScheme)
    {
        highlightScheme = highlightScheme || me.highlightScheme;

        var result = {};
        indexOffset = indexOffset || 0;

        var noteLabel = function(labelName, indexStart, indexStop, labelType, linkTo)
        {
            if (!result[labelName])
            {
                result[labelName] = [];
            }

            if (indexStart >= 0)
            {
                indexStart += indexOffset;
            }

            if (indexStop >= 0)
            {
                indexStop += indexOffset;
            }

            if (highlightScheme.labelExtensions && highlightScheme.labelExtensions.end[labelName] && indexStop >= 0
                    && labelType !== SyntaxHelper.LABEL_START)
            {
                if (labelType === SyntaxHelper.LABEL_END)
                {
                    indexStart += highlightScheme.labelExtensions.end[labelName];
                }

                indexStop += highlightScheme.labelExtensions.end[labelName];
            }

            if (highlightScheme.labelExtensions && highlightScheme.labelExtensions.start[labelName] && indexStart >= 0
                    && labelType !== SyntaxHelper.LABEL_END)
            {
                if (labelType === SyntaxHelper.LABEL_START)
                {
                    indexStop += highlightScheme.labelExtensions.start[labelName];
                }

                indexStart += highlightScheme.labelExtensions.start[labelName];
            }

            let newLabel = new SyntaxLabel(labelName, indexStart, indexStop, labelType, linkTo);

            result[labelName].push(newLabel);

            return newLabel;
        };

        var handlePart = function(labelName, partContent, partIndex)
        {
            var handledPart = false;
            var startRegex = highlightScheme.labelSearchRegexes.start[labelName];
            var stopRegex = highlightScheme.labelSearchRegexes.end[labelName];

            var handleRegex = function(content, regex, markerType, mirrorLabels)
            {
                var lastIndex = -1, regexResult, currentIndex, currentEndIndex, mirrorLabel = undefined, shouldContinue,
                        currentChar;
                let result = {};

                //console.warn(mirrorLabels);
                regex.lastIndex = 0;

                do
                {
                    regexResult = regex.exec(content);

                    if (regexResult != null)
                    {
                        currentIndex = regexResult.index;
                        currentEndIndex = regex.lastIndex;

                        if (currentIndex > 0 && content.charAt(currentIndex - 1) === "\\")
                        {
                            shouldContinue = false;
                            
                            let walkbackIndex = 1, count = 0;
                            
                            do
                            {
                                currentChar = content.charAt(currentIndex - walkbackIndex);
                                
                                count++;
                                
                                walkbackIndex++;
                            }
                            while (currentChar === "\\" && currentIndex - walkbackIndex >= 0);
                            
                            if (count % 2 === 0) // === because count++ also happens for first non backslash character.
                            {
                                continue;
                            }
                        }

                        if (mirrorLabels && currentIndex in mirrorLabels && mirrorLabels[currentIndex].end === currentEndIndex
                            && mirrorLabels[currentIndex].content == regexResult[0])
                        {
                            mirrorLabel = mirrorLabels[currentIndex].label;
                        }

                        result[currentIndex] = { end: currentEndIndex, label: noteLabel(labelName, currentIndex, currentEndIndex, markerType, mirrorLabel),
                                                 content: regexResult[0] };
                    }
                    else
                    {
                        break;
                    }
                }
                while (lastIndex < currentIndex);

                return result;
            };

            var startLabels = [];

            if (startRegex && startRegex.exec)
            {
                startLabels = handleRegex(partContent, startRegex, SyntaxHelper.LABEL_START);

                handledPart = true;
            }

            if (stopRegex && stopRegex.exec)
            {
                handleRegex(partContent, stopRegex, SyntaxHelper.LABEL_END, startLabels);

                handledPart = true;
            }

            // If another method was not used,
            //check whether the part is equivalent to
            //the label's name.
            if (!handledPart)
            {
                if (partContent === labelName)
                {
                    noteLabel(labelName, partIndex - labelName.length, partIndex, SyntaxHelper.LABEL_SINGLE);
                }
            }
        };

        var handleLabel = function(labelName)
        {
            // Check for a splitting method...
            if (highlightScheme.labelSearchSeparators[labelName] !== SyntaxHelper.SEARCH_ALL)
            {
                // Use the standard separator if none were specified.
                var splitMethod = highlightScheme.labelSearchSeparators[labelName] !== undefined ? highlightScheme.labelSearchSeparators[labelName] : SyntaxHelper.STANDARD_SEPARATORS;
                var splitChars = {};
                var index;

                var splitAll = (splitMethod === SyntaxHelper.SINGLE_CHAR_SEPARATOR || splitMethod.length === 0);
                var indexShift = 0;

                if (splitAll)
                {
                    indexShift = 1;
                }

                var buffer = "", currentChar;

                for (index = 0; index < splitMethod.length; index++)
                {
                    currentChar = splitMethod.charAt(index);

                    // Note the current character's usability as a split character.
                    splitChars[currentChar] = true;
                }

                // Handle each part of the text.
                for (index = 0; index <= text.length; index++)
                {
                    // If a character is to be accessed,
                    if (index < text.length)
                    {
                        currentChar = text.charAt(index);
                    }

                    // If ending, or the current character is to be used to split segments,
                    if (index === text.length || (splitAll && currentChar !== "\\") || currentChar in splitChars)
                    {
                        if (splitAll && index !== text.length)
                        {
                            buffer += currentChar;
                        }

                        //console.log("Handling part: " + buffer + " at index " + index + ". Label: " + labelName + ".");
                        handlePart(labelName, buffer, index + indexShift, highlightScheme);

                        buffer = "";
                    }
                    else // Otherwise, add to the buffer.
                    {
                        buffer += currentChar;
                    }
                }
            }
            else
            {
                handlePart(labelName, text, 0, highlightScheme);
            }
        };

        /* For all findable labels... */
        for (var labelName in highlightScheme.labelMap)
        {
            handleLabel(labelName);
        }

        return result;
    };

    this.labelCanMultiLine = function(labelName, highlightScheme)
    {
        highlightScheme = highlightScheme || me.highlightScheme;

        if (highlightScheme.multiLineLabels && labelName in highlightScheme.multiLineLabels)
        {
            return highlightScheme.multiLineLabels[labelName];
        }

        return false;
    };

    var getDepthSortedLabels = function(appliedLabels)
    {
        var allLabels = [];
        var i;

        for (var label in appliedLabels)
        {
            for (i = 0; i < appliedLabels[label].length; i++)
            {
                allLabels.push(appliedLabels[label][i]);
            }
        }

        allLabels.sort((a, b) => (a.depth - b.depth));

        return allLabels;
    };

    this.getHighlightScheme = function(appliedLabels, missingDependencyCheck, sortedLabels)
    {
        var allLabels = sortedLabels || getDepthSortedLabels(appliedLabels);

        var highlightSignificantLabels = [];
        var lastHighlighter = me.highlightScheme;

        for (var i = 0; i < allLabels.length; i++)
        {
            if (lastHighlighter.highlightSchemeSpecificLabels[allLabels[i].tagName] && !missingDependencyCheck(allLabels[i]))
            {
                lastHighlighter = lastHighlighter.highlightSchemeSpecificLabels[ allLabels[i].tagName ];

                //console.log("SWITCHED HIGHLIGHTER AT REQUEST OF " + allLabels[i].tagName);
            }
        }

        return lastHighlighter;
    };

    this.getMissingDependencyCheck = function(appliedLabels)
    {
        var allLabelIds = {};
        var i = 0;

        for (var labelName in appliedLabels)
        {
            for (i = 0; i < appliedLabels[labelName].length; i++)
            {
                allLabelIds[appliedLabels[labelName][i].getId()] = true;//appliedLabels[labelName][i];
            }
        }

        //console.log(allLabelIds);

        // Whether MISSING a dependency.
        var depCheck =
        (labelObject) =>
        {
            //console.log(labelObject.dependsOn);

            for (var key in labelObject.dependsOn)
            {
                if (!allLabelIds[key])
                {
                    return true;
                }
            }

            return false;
        };

        return depCheck;
    };

    this.labelSwapsHighlighter = function(label, highlighter)
    {
        return highlighter.highlightSchemeSpecificLabels[label] !== undefined;
    };
}

let __LABEL_ID__ = 0;
function SyntaxLabel(tagName, startIndex, endIndex, labelType, linkTo)
{
    const me = this;

    this.tagName = tagName;

    this.startIndex = startIndex || 0;
    this.endIndex = endIndex !== undefined ? endIndex : SyntaxHelper.END_OF_LINE;
    this.labelType = labelType;
    this.linkedTo = linkTo;
    this.labelId = (__LABEL_ID__++);
    this.dependsOn = {};
    this.depth = 0;

    var disabled = false;

    this.equivalentTo = function(other)
    {
        return me.startIndex === other.startIndex && me.endIndex === other.endIndex && me.labelType === other.labelType && me.tagName === other.tagName;
    };

    this.clearDependencies = function()
    {
        me.dependsOn = {};
        me.depth = 0;
    };

    this.getDependsOn = function(other)
    {
        return me.dependsOn[other.labelId] != undefined;
    };

    this.addDependency = function(newDependency)
    {
        this.dependsOn[newDependency.labelId] = true;
        me.depth ++;
    };

    this.getId = function()
    {
        return me.labelId;
    };

    this.disable = function()
    {
        disabled = true;
    };

    this.getDisabled = function()
    {
        return disabled;
    };
};

function SyntaxTracker(currentLine, previousLine, nextLine, syntaxSelector)
{
    const me = this;

    me.currentLine = currentLine;
    me.nextLine = nextLine || null;
    me.previousLine = previousLine || null;
    me.syntaxSelector = syntaxSelector;

    me.labels = {};
    me.continuedLabels = {};

    var linkLabels = function(forbiddenStartIndicies, labelSubset, highlightScheme)
    {
        var labelIndex, currentLabel, startingLabels = [], endingLabels = [], unendedLabels = [];
        var labels = labelSubset || me.labels;


        // Check whether new continued labels are to be created...
        for (var labelName in labels)
        {
            for (labelIndex = 0; labelIndex < labels[labelName].length; labelIndex++)
            {
                currentLabel = labels[labelName][labelIndex];

                // If a starting label...
                if (currentLabel.labelType === SyntaxHelper.LABEL_START
                        && !(currentLabel.startIndex in forbiddenStartIndicies))
                {
                    startingLabels.push(currentLabel);
                }
                else if (currentLabel.labelType === SyntaxHelper.LABEL_END)
                {
                    endingLabels.push(currentLabel);

                    //console.log(currentLabel.tagName);
                }
            }
        }

        var testIndex, matchedWith;

        // Search for ending labels for every starting label.
        //Unfortunately, this is quadratic... TODO Fix this.
        for (labelIndex = 0; labelIndex < startingLabels.length; labelIndex++)
        {
            currentLabel = startingLabels[labelIndex];

            if (currentLabel.getDisabled())
            {
                continue;
            }

            matchedWith = undefined;

            for (testIndex = 0; testIndex < endingLabels.length; testIndex++)
            {
                if (endingLabels[testIndex].tagName === currentLabel.tagName && (endingLabels[testIndex].startIndex >= currentLabel.endIndex && currentLabel.endIndex !== SyntaxHelper.END_OF_LINE)
                    && (!matchedWith || matchedWith.endIndex > endingLabels[testIndex].endIndex || matchedWith.endIndex === SyntaxHelper.END_OF_LINE))
                {
                    matchedWith = endingLabels[testIndex];
                }
            }

            if (matchedWith)
            {
                me.labels[currentLabel.tagName].push(new SyntaxLabel(currentLabel.tagName, currentLabel.endIndex, matchedWith.endIndex, SyntaxHelper.LABEL_SINGLE));

                if (matchedWith.linkedTo)
                {
                    matchedWith.linkedTo.disable();
                }

                // If the label can be multi-line, and the next line has that label,
                if (me.nextLine && me.syntaxSelector.labelCanMultiLine(currentLabel.tagName, highlightScheme) && me.nextLine.syntaxTracker.hasLabelToEndOfLine(currentLabel.tagName))
                {
                    // Update the next line.
                    me.nextLine.requestRefresh();
                }
            }
            else
            {
                // Apply the label to the next line.
                if (me.nextLine && me.syntaxSelector.labelCanMultiLine(currentLabel.tagName, highlightScheme))
                {
                    me.nextLine.requestRefresh();//syntaxTracker.applyContinuingLabel(currentLabel.tagName);
                }

                // Make the label span to the end of the line.
                currentLabel.endIndex = SyntaxHelper.END_OF_LINE;
            }
        }
    };

    // DANGER!! Only to be used after clearing
    //me.labels, as this function adds its
    //continuedLabels to the current ones.
    var refreshContinuedLabels = function(noLink, preventAppendContinued)
    {
        var forbiddenStartIndicies = {}, hasContinuingStart;

        for (var label in me.continuedLabels)
        {
            hasContinuingStart = false;

            if (me.labels[label])
            {
                for (var i = 0; i < me.labels[label].length; i++)
                {
                    if (me.labels[label][i].labelType === SyntaxHelper.LABEL_START)
                    {
                        hasContinuingStart = true;

                        break;
                    }
                }
            }

            let endLabels = me.getEndLabels(label, 1);

            // If the previous line doesn't have
            //the label, don't apply it.
            if (me.previousLine && (!me.previousLine.syntaxTracker.hasLabel(label) || !me.previousLine.syntaxTracker.hasLabelToEndOfLine(label)))
            {
                delete me.continuedLabels[label];

                if (me.labels[label])
                {
                    delete me.labels[label];
                }

                if (me.nextLine && me.nextLine.syntaxTracker.hasLabel(label))
                {
                    me.nextLine.requestRefresh();
                }

                continue;
            }
            else if (me.continuedLabels[label].endIndex !== SyntaxHelper.END_OF_LINE && endLabels.length === 0)
            {
                me.continuedLabels[label].endIndex = SyntaxHelper.END_OF_LINE;

                if (me.nextLine && !me.nextLine.syntaxTracker.hasLabel(label))
                {
                    me.nextLine.requestRefresh();
                }
            }
            else if (endLabels.length > 0 && me.continuedLabels[label].endIndex !== endLabels[0].startIndex)
            {
                me.continuedLabels[label].endIndex = endLabels[0].startIndex;

                if (me.nextLine && me.nextLine.syntaxTracker.hasLabel(label))
                {
                    me.nextLine.requestRefresh();
                }
            }

            if (me.continuedLabels[label].endIndex !== SyntaxHelper.END_OF_LINE && me.nextLine && me.nextLine.syntaxTracker.hasLabelToEndOfLine(label))
            {
                me.nextLine.requestRefresh();
            }

            if (me.continuedLabels[label].endIndex === SyntaxHelper.END_OF_LINE && me.nextLine && !me.nextLine.syntaxTracker.hasLabel(label))
            {
                me.nextLine.requestRefresh();
            }

            if (!me.labels[label])
            {
                me.labels[label] = [];
            }

            if (!preventAppendContinued)
            {
                me.labels[label].push(me.continuedLabels[label]);
            }

            if (me.continuedLabels[label].endIndex != SyntaxHelper.END_OF_LINE)
            {
                forbiddenStartIndicies[me.continuedLabels[label].endIndex] = true;

                forbiddenStartIndicies[me.continuedLabels[label].startIndex] = true;
            }
        }

        if (!noLink)
        {
            linkLabels(forbiddenStartIndicies);
        }

        return forbiddenStartIndicies;
    };

    var lastRefreshTime = 0,//(new Date()).getTime(),
        awaitingTimeout = false,
        minRefreshDeltaT = 500;

    this.refreshHighliting = function(ignoreForDeltaT)
    {
        var nowTime = (new Date()).getTime();
        var dt = nowTime - lastRefreshTime;

        if (dt > minRefreshDeltaT || ignoreForDeltaT)
        {
            me.labels = me.syntaxSelector.getLabelIndicies(me.currentLine.text);

            // Check the previous line for multi-line labels to be extended.
            if (me.previousLine)
            {
                me.previousLine.syntaxTracker.applyAnyToBeContinuedLabels(me);
            }

            refreshContinuedLabels();

            //linkLabels();
            me.updateLabelDeps();

            me.checkAndHandleOtherHighlightSchemes(0, me.currentLine.text.length); // Check whether the current highlighter requests a change in highlighting. Discover new labels if it does.

            lastRefreshTime = nowTime;

            awaitingTimeout = false;
        }
        else if (!awaitingTimeout)
        {
            setTimeout(() => me.refreshHighliting(), minRefreshDeltaT - dt);

            awaitingTimeout = true;
        }
    };

    this.getTextInLabel = function(labelName, labelIndex)
    {
        var label = me.labels[labelName][labelIndex];
        var endIndex = label.endIndex;
        var startIndex = label.startIndex;

        //console.log("   End (prior to check in getText): " + endIndex);

        if (endIndex == SyntaxHelper.END_OF_LINE)
        {
            endIndex = me.currentLine.text.length;
        }

        //console.log("  Getting text from label, " + labelName + ", at index " + labelIndex + ". The text starts at " + startIndex + " and ends at " + endIndex + ".");

        return me.currentLine.text.substring(startIndex, endIndex);
    };

    var noteNewLabels = function(labelsMap)
    {
        let i = 0;

        for (var labelName in labelsMap)
        {
            if (!me.hasLabel(labelName))
            {
                me.labels[labelName] = [];
            }

            for (i = 0; i < labelsMap[labelName].length; i++)
            {
                me.labels[labelName].push(labelsMap[labelName][i]);
            }
        }
    };

    this.checkAndHandleOtherHighlightSchemes = function(startIndex, stopIndex, currentHighlighter, recursionDepth)
    {
        let i = 0, newHighlighter, additionalLabels,
            currentStart, currentEnd,
            currentLabel,
            getEndIndex = (labelObj) =>
            {
                return labelObj.endIndex !== SyntaxHelper.END_OF_LINE ? labelObj.endIndex : me.currentLine.text.length;
            };

        // If recursing more than 15 times, an error probably has occurred! Log and return.
        if (recursionDepth > 15)
        {
            console.error("recursionDepth > 15 (checkAndHandleOtherHighlightSchemes).");

            return false;
        }

        let handleLabel = (labelText, startIndex, endIndex) =>
        {
            newHighlighter = currentHighlighter.highlightSchemeSpecificLabels[labelName];

            additionalLabels = me.syntaxSelector.getLabelIndicies(labelText,
                        startIndex, newHighlighter
                        );



            noteNewLabels(additionalLabels);

            if (me.previousLine)
            {
                me.previousLine.syntaxTracker.applyAnyToBeContinuedLabels(me, true, newHighlighter);
            }


            let forbiddenStartIndicies = refreshContinuedLabels(true, true);
            linkLabels(forbiddenStartIndicies, additionalLabels, newHighlighter);
            me.updateLabelDeps();

            me.checkAndHandleOtherHighlightSchemes(currentStart,
                    currentEnd, newHighlighter, recursionDepth + 1);
        };

        currentHighlighter = currentHighlighter || me.syntaxSelector.highlightScheme;

        for (var labelName in currentHighlighter.highlightSchemeSpecificLabels)
        {
            if (me.hasLabel(labelName))
            {
                //console.log("Got the label " + labelName + "! START_CHECK: " + startIndex + "; STOP_CHECK: " + stopIndex + ", list: " + me.labels[labelName].join(", "));

                if (me.labels[labelName].length === 0)
                {
                    handleLabel(me.currentLine.text, 0, me.currentLine.text.length);
                }

                for (i = 0; i < me.labels[labelName].length; i++)
                {
                    currentLabel = me.labels[labelName][i];
                    currentStart = currentLabel.startIndex;

                    if (currentStart >= startIndex && currentStart <= stopIndex)
                    {
                        handleLabel(me.getTextInLabel(labelName, i), currentStart, getEndIndex(currentLabel));
                    }
                }
            }
        }
    };

    this.getEndLabels = function(label, maxNumber)
    {
        if (!(label in me.labels))
        {
            return [];
        }

        maxNumber = maxNumber || me.labels[label].length;

        var result = [];

        for (var i = 0; i < me.labels[label].length; i++)
        {
            if (me.labels[label][i].labelType === SyntaxHelper.LABEL_END)
            {
                result.push(me.labels[label][i]);

                if (result.length >= maxNumber)
                {
                    break;
                }
            }
        }

        return result;
    }

    this.getColorAtIndex = function(characterIndex)
    {
        var result = me.syntaxSelector.getBaseColor();

        var applicableLabels = {};

        var handleLabel = function(label)
        {
            if (label.startIndex <= characterIndex
                && (label.endIndex > characterIndex
                    || label.endIndex === SyntaxHelper.END_OF_LINE))
            {
                if (!applicableLabels[label.tagName])
                {
                    applicableLabels[label.tagName] = [];
                }

                applicableLabels[label.tagName].push(label);

                d += ", " + label.tagName;
            }
        };

        var d = "";
        var i;
        for (var labelName in me.labels)
        {
            for (i = 0; i < me.labels[labelName].length; i++)
            {
                handleLabel(me.labels[labelName][i]);
            }
        }

        //console.log(d);
        //console.log(me.labels);

        return me.syntaxSelector.getColor(applicableLabels);
    };

    this.applyContinuingLabel = function(label)
    {
        var endIndex = SyntaxHelper.END_OF_LINE;

        /* If the label does not exist... */
        if (!me.labels[label])
        {
            me.labels[label] = [];
        }
        else
        {
            var endLabel;

            for (var i = 0; i < me.labels[label].length; i++)
            {
                if (me.labels[label][i].labelType === SyntaxHelper.LABEL_END && (me.labels[label][i].startIndex < endIndex || endIndex === -1))
                {
                    endIndex = me.labels[label][i].startIndex;

                    endLabel = me.labels[label][i];
                    break;
                }
            }

            if (endLabel && endLabel.linkedTo)
            {
                endLabel.linkedTo.disable();
            }
        }

        let newLabel = new SyntaxLabel(label, 0, endIndex, SyntaxHelper.LABEL_CONTINUED);

        // DO NOT apply the label if it already exists.
        if (!me.continuedLabels[label] || !newLabel.equivalentTo(me.continuedLabels[label]))
        {
            me.labels[label].push(newLabel);
            me.continuedLabels[label] = newLabel;

            /* Wait, then apply the label to the following line. */
            if (me.nextLine && me.nextLine.syntaxTracker && endIndex == SyntaxHelper.END_OF_LINE)
            {
                me.nextLine.requestRefresh();
            }
        }
    };

    this.hasLabel = function(label)
    {
        return (label in me.labels);
    };

    this.hasLabelToEndOfLine = function(label)
    {
        if (!me.hasLabel(label))
        {
            return false;
        }

        for (var i = 0; i < me.labels[label].length; i++)
        {
            if (me.labels[label][i].endIndex === SyntaxHelper.END_OF_LINE && me.labels[label][i].labelType !== SyntaxHelper.LABEL_END)
            {
                return true;
            }
        }

        return false;
    };

    this.applyAnyToBeContinuedLabels = function(toLine, excludeContinuedLabels, highlighter)
    {
        var appliedLabels = {};

        if (!excludeContinuedLabels)
        {
            for (var label in me.continuedLabels)
            {
                if (label.endIndex === SyntaxHelper.END_OF_LINE && !appliedLabels[label] && me.hasLabelToEndOfLine(label) && !toLine.hasLabelToEndOfLine(label))
                {
                    toLine.applyContinuingLabel(label);
                    appliedLabels[label] = true;
                }
            }
        }

        for (var label in me.labels)
        {
            if (me.syntaxSelector.labelCanMultiLine(label, highlighter) && me.hasLabelToEndOfLine(label) && !appliedLabels[label] && !toLine.hasLabelToEndOfLine(label))
            {
                toLine.applyContinuingLabel(label);
                appliedLabels[label] = true;
            }
        }
    };

    /*
    Determine and set the precedence of all labels
    applied to this line. ACQUIRE THIS LIST BEFORE
    CALLING THIS.
    */
    this.updateLabelDeps = function()
    {
        let allLabels = [];
        let i = 0, j = 0;

        // TODO: Consider caching a copy of allLabels to
        //prevent its regeneration.
        for (var key in me.labels)
        {
            for (i = 0; i < me.labels[key].length; i++)
            {
                allLabels.push(me.labels[key][i]);

                me.labels[key][i].clearDependencies();
                me.labels[key][i].updateLabelDeps__tempEndIndex = undefined;
            }
        }

        // Sort the labels by starting-index.
        allLabels.sort((a, b) =>
        {
            return a.startIndex - b.startIndex;
        });

        let getLength = (label) =>
        {
            let endIndex = label.endIndex;

            if (label.endIndex === SyntaxHelper.END_OF_LINE)
            {
                endIndex = me.currentLine.text.length;
            }

            if (label.updateLabelDeps__tempEndIndex !== undefined)
            {
                endIndex = label.updateLabelDeps__tempEndIndex;
            }

            return endIndex - label.startIndex;
        };

        if (allLabels.length > 0)
        {
            let currentLength = 0;
            let currentEndIndex = 0;

            for (i = 0; i < allLabels.length; i++)
            {
                currentLength = getLength(allLabels[i]);
                currentEndIndex = allLabels[i].startIndex + currentLength;

                if (currentLength <= 1 || allLabels[i].labelType === SyntaxHelper.LABEL_START || allLabels[i].labelType === SyntaxHelper.LABEL_END)
                {
                    continue;
                }

                for (j = i + 1; j < allLabels.length && allLabels[j].startIndex < currentEndIndex; j++)
                {
                    allLabels[j].addDependency(allLabels[i]);

                    if (allLabels[j].startIndex + getLength(allLabels[j]) > currentEndIndex)
                    {
                        allLabels[j].endIndex = currentEndIndex;
                    }
                }
            }

            return true;
        }

        return false;
    };
}

</script>


<!-- Inserted file  "Line.js" encoding = "utf-8". -->
<script>
"use strict";

var __lineIdCounter = 0;
function Line(ctx, parentEditor, x, y, h, myIndex)
{
    this.ctx = ctx;
    this.text = "";
    this.cursorPosition = 0;
    this.maxCursorPosition = 0;
    this.h = h;
    this.x = x;
    this.y = y;
    this.noXFocusCheck = true;
    this.parentEditor = parentEditor;
    this.hasFocus = false;
    this.hadFocus = false;
    this.syntaxTracker = new SyntaxTracker(this, null, null, parentEditor.syntaxSelector);
    
    this.lastModifiedTime = (new Date()).getTime();
    this.creationTime = (new Date()).getTime();
    this.id = "id_" + (__lineIdCounter++);

    this.lastRefreshText = "";
    this.refreshRequested = true;

    this.editable = true;
    this.onentercommand = null;

    this.selRange = [];

    this.selColor = "#441144";
    this.color = "white";

    this.flaggedForRemoval = false;

    const me = this;

    this.requestRender = function()
    {
        me.parentEditor.render();
    };

    this.requestRefresh = function()
    {
        me.refreshRequested = true;
    };

    this.render = function(index, trueIndex)
    {
        me.y = index * me.h + me.parentEditor.y;

        if (me.y + me.h < 0 || me.x + me.getWidth() < 0 || me.y > me.ctx.canvas.height)
        {
            return;
        }

        const codeEditing = me.parentEditor.isCodeEditing();

        me.refreshHighlitingIfNeeded(trueIndex);

        const getCharColor = function(index)
        {
            if (!codeEditing)
            {
                return me.color;
            }

            /*
             Get the context of the current part of
             the line. Stop search with space characters,
             etc.
            */

            //console.log("CHAR: " + currentCharacter);

            const color = me.syntaxTracker.getColorAtIndex(index);

            return color;
        };
        
        const canvasWidth = me.ctx.canvas.width;

        var currentChar, x = me.x, y = me.y,
            hasSelection = me.hasSelection(),
            currentCharW;

        for (var i = 0; i <= me.text.length; i++)
        {
            me.ctx.save();

            if (i < me.text.length)
            {
                currentChar = me.text.charAt(i);

                currentCharW = me.ctx.measureText(currentChar).width;

                if (hasSelection && i >= me.selRange[0] && i < me.selRange[1])
                {
                    me.ctx.fillStyle = me.selColor;

                    me.ctx.fillRect(x, y, currentCharW, me.h);
                }
            }

            if (i === me.cursorPosition && me.hasFocus)
            {
                me.ctx.fillStyle = me.color;
                me.ctx.fillRect(x, y, 1, me.h * 0.99);
            }


            if (i < me.text.length)
            {
                me.ctx.fillStyle = getCharColor(i);

                me.ctx.fillText(currentChar, x, y);

                x += currentCharW;
            }

            me.ctx.restore();
            
            if (x > canvasWidth)
            {
                return;
            }
        }

        /* Show the entire selection! */
        if (hasSelection && (me.text.length === 0 || (me.selRange[1] === me.text.length)))
        {
            me.ctx.save();

            me.ctx.beginPath();
            me.ctx.fillStyle = me.selColor;
            me.ctx.fillRect(x, y, me.ctx.canvas.width, me.h);

            me.ctx.restore();
        }
    };

    this.getWidth = function()
    {
        return me.ctx.measureText(me.text).width;
    };

    this.checkCollision = function(index, point)
    {
        me.y = index * me.h + me.parentEditor.y;

        return (point.x > me.x && point.x < me.x + me.getWidth() || me.noXFocusCheck) && point.y > me.y && point.y < me.y + me.h;
    };

    this.handleClick = function(index, point, screenIndex)
    {
        if (me.checkCollision(screenIndex, point))
        {
            var x = me.x, newX, i;
            var currentChar;

            me.hasFocus = true;

            me.cursorPosition = me.text.length;

            for (i = 0; i < me.text.length; i++)
            {
                currentChar = me.text.charAt(i);

                newX = x + me.ctx.measureText(currentChar).width;

                if (x <= point.x && newX >= point.x)
                {
                    me.cursorPosition = i;
                }

                x = newX;
            }

            if (point.x < me.x)
            {
                me.cursorPosition = 0;
            }

            me.parentEditor.shiftViewIfNecessary(index, screenIndex);
        }
        else
        {
            me.hasFocus = false;
        }

        me.deselect();
    };

    this.prepareToHandleKey = function()
    {
        me.hadFocus = me.hasFocus;
    };

    this.afterHandleKey = function(myIndex)
    {
        if (me.hasFocus)
        {
            me.parentEditor.shiftViewIfNecessary(myIndex, me.text.length);
        }
    };

    this.transitionFocus = function(fromLine, otherWayLine)
    {
        if (!fromLine)
        {
            return;
        }

        if (fromLine.hadFocus)
        {
            me.hasFocus = true;
            fromLine.hasFocus = false;

            me.cursorPosition = Math.max(fromLine.cursorPosition, fromLine.maxCursorPosition);

            me.maxCursorPosition = me.cursorPosition;

            me.cursorPosition = Math.min(me.text.length, me.cursorPosition);
        }

        if (me.hadFocus && otherWayLine)
        {
            me.hasFocus = false;
        }
    };

    this.lrTransitionFocus = function(toLine, direction)
    {
        if (me.hadFocus)
        {
            if (me.cursorPosition + direction >= 0 && me.cursorPosition + direction <= me.text.length)
            {
                me.cursorPosition += direction;
            }
            else if (toLine)
            {
                me.hasFocus = false;

                toLine.hasFocus = true;

                if (direction < 0)
                {
                    toLine.cursorPosition = toLine.text.length;
                }
                else
                {
                    toLine.cursorPosition = 0;
                }
            }
        }
    };

    this.handleKey = function(key, lineAbove, lineBelow, myIndex, ignoreSpecial)
    {
        if (!me.hasFocus && !me.hadFocus && !me.hasSelection() && lineAbove
            && lineBelow && !lineAbove.hadFocus && !lineBelow.hadFocus)
        {
            return;
        }

        var added = false;

        if (!ignoreSpecial)
        {
            if (key === "üîΩ" || key === "ArrowDown")
            {
                me.transitionFocus(lineAbove, lineBelow);

                added = true;
            }
            else if (key === "üîº" || key === "ArrowUp")
            {
                me.transitionFocus(lineBelow, lineAbove);

                added = true;
            }
            else if (key === "‚óÄÔ∏è" || key === "ArrowLeft")
            {
               me.lrTransitionFocus(lineAbove, -1);

                added = true;

                me.maxCursorPosition = 0;
            }
            else if (key === "‚ñ∂Ô∏è" || key === "ArrowRight")
            {
               me.lrTransitionFocus(lineBelow, 1);

                added = true;

                me.maxCursorPosition = 0;
            }
        }

        var hasSelection = me.hasSelection();

        if (hasSelection && !added && me.parentEditor.editable && me.editable)
        {
            me.text = me.text.substring(0, me.selRange[0]) + me.text.substring(me.selRange[1]);

            me.cursorPosition = me.selRange[0];

            me.deselect();
        }

        if (me.hadFocus && !added && me.parentEditor.editable && me.editable)
        {
            if ((key === "‚è™" || key === "Backspace") && !ignoreSpecial)
            {
                if (me.cursorPosition === 0)
                {
                    if (lineAbove)
                    {
                       me.flaggedForRemoval = true;

                        me.lrTransitionFocus(lineAbove, -1);

                        lineAbove.text += me.text;
                    }
                }
                else if (!hasSelection)
                {
                    me.cursorPosition--;

                    me.text = me.text.substring(0, me.cursorPosition) + me.text.substring(me.cursorPosition + 1);
                }
            }
            else if (((key === "‚è¨" || key === "Enter") && !ignoreSpecial) || key === "\n")
            {
                if (!me.onentercommand)
                {
                    var movedText = me.text.substring(me.cursorPosition);
                    me.text = me.text.substring(0, me.cursorPosition);

                    var originalMovedText = movedText;

                    if (me.parentEditor.isCodeEditing() && key !== "\n")
                    {
                        movedText = me.getStartingSpace() + movedText;
                    }


                    var newLine = me.parentEditor.addLine(myIndex + 1, movedText);

                    me.lrTransitionFocus(newLine, 1);

                    newLine.cursorPosition = newLine.text.length - originalMovedText.length;
                    newLine.refreshHighlitingIfNeeded(myIndex + 1);
                    
                    me.requestRefresh();
                }
            }
            else
            {
                var toInsert = key;

                if (key === "_SPACE_" && !ignoreSpecial)
                {
                    toInsert = " ";
                }
                else if (key === "Tab" && !ignoreSpecial)
                {
                    toInsert = "    ";
                }

                me.text = me.text.substring(0, me.cursorPosition) + toInsert + me.text.substring(me.cursorPosition);

                me.cursorPosition += toInsert.length;
                me.maxCursorPosition = 0;
            }
        }

        if (hasSelection && !added && me.text.length === 0)
        {
            me.flaggedForRemoval = true;
        }

        if (me.hadFocus && me.onentercommand && (key === "‚è¨" || key === "\n" || key === "Enter"))
        {
            try
            {
                me.onentercommand(me, myIndex);
            }
            catch(e)
            {
                noteError(e);
            }
        }

        me.updateModifiedTime();
        me.refreshHighlitingIfNeeded(myIndex);
    };

    this.refreshHighlitingIfNeeded = function(myIndex, force, ignoreTimeout)
    {
        const codeEditing = me.parentEditor.isCodeEditing();

        me.syntaxTracker.nextLine = me.parentEditor.lines[myIndex + 1];
        me.syntaxTracker.previousLine = me.parentEditor.lines[myIndex - 1];

        // If code-editing, update the next and previous lines.
        if (codeEditing && (me.lastRefreshText != me.text || force || me.refreshRequested))
        {
            // Also update the highliting.
            me.syntaxTracker.refreshHighliting(ignoreTimeout);

            me.lastRefreshText = me.text + ""; // Cache the line's text.

            me.refreshRequested = false;
        }
    };
    
    this.getText = function()
    {
        return me.text;
    };
    
    this.setText = function(newText)
    {
        var oldText = me.text + "";
        
        me.text = newText;
        
        if (oldText !== newText)
        {
            me.lastModifiedTime = (new Date()).getTime();
        }
    };
    
    var lastText = "";
    this.updateModifiedTime = function()
    {
        if (me.text !== lastText)
        {
            me.lastModifiedTime = (new Date()).getTime();
        }
    };
    
    this.setModifiedTime = function(lastTime)
    {
        me.lastModifiedTime = lastTime;
        
        lastText = me.text;
    };
    
    this.getLastTimeModified = function()
    {
        return me.lastModifiedTime;
    };

    this.select = function(selStart, selEnd)
    {
        me.selRange = [Math.max(0, selStart || 0), Math.min(selEnd !== undefined ? selEnd : me.text.length, me.text.length)];
    };

    this.deselect = function()
    {
        me.selRange = [];
    };

    this.hasSelection = function()
    {
        return me.selRange.length === 2;/* && me.selRange[0] !== me.selRange[1];*/
    };

    this.getSelectedText = function()
    {
        if (!me.hasSelection())
        {
            return "";
        }

        var selStart = me.selRange[0],
            selEnd   = me.selRange[1];

        return me.text.substring(selStart, selEnd);
    };

    this.getStartingSpace = function()
    {
        var result = "", currentChar;

        for (var i = 0; i < me.text.length; i++)
        {
            currentChar = me.text.charAt(i);

            if (currentChar !== " ")
            {
                return result;
            }

            result += currentChar;
        }

        return result;
    };

    this.indent = function(spacesCount)
    {
        var startingSpaces = "";

        for (var i = 0; i < spacesCount; i++)
        {
            startingSpaces += " ";
        }

        if (me.parentEditor.editable && me.editable)
        {
            me.text = startingSpaces + me.text;
        }
        
        me.updateModifiedTime();
    };

    this.deindent = function(maxSpaces)
    {
        var totalSpaces = me.getStartingSpace().length;

        maxSpaces = Math.min(totalSpaces, maxSpaces);

        if (me.parentEditor.editable && me.editable)
        {
            me.text = me.text.substring(maxSpaces);
        }
        
        me.updateModifiedTime();
    };

    this.focus = function()
    {
        me.parentEditor.unfocus();

        me.hasFocus = true;
        me.hadFocus = true;
    };

    this.unfocus = function()
    {
        me.hasFocus = false;
        me.hadFocus = false;
    };
}


</script>


<!-- Inserted file  "Editor.js" encoding = "utf-8". -->
<script>
"use strict";

const EDITOR_SOURCE = "<!DOCTYPE " + "html>\n"
                     +
                     `
                     <!--
                        Note: This source listing includes only
                        INLINE script blocks. If this is the 
                        chunked version of the editor, these
                        will not be visible in this
                        listing.
                     \-->
                     `
                     + 
                     document.documentElement.outerHTML;

const VERSION_CODE = "1.06 (Main)";

function EditControl(ctx)
{
    this.x = 0;
    this.y = 0;
    this.ctx = ctx;
    this.font = "10pt courier, monospace, sans-serif";

    this.syntaxSelector = new SyntaxSelector();

    this.selecting = false;
    this.ctx.font = this.font;

    this.codeEditing = true;
    this.editable = true;

    this.lineH = this.ctx.measureText("M").width * 1.3;

    this.viewOffset = 0;

    this.lines = [];

    this.removed = [];
    this.stateSaves = [];
    
    this.trackRemoved = false;

    const me = this;

    this.setDefaultHighlightScheme = function(key)
    {
        me.syntaxSelector.setDefaultHighlightScheme(key);
    };
    
    // Returns an object that can be used to
    //modify the editor's lines.
    this.getLineHelper = function()
    {
        var result = 
        {
            insert: (index, text, mockCreationTime) =>
            {
                var newLine = me.addLine(index, text);
                
                newLine.creationTime = mockCreationTime;
                
                if (mockCreationTime !== undefined)
                {
                    newLine.setModifiedTime(mockCreationTime);
                }
            },
            
            update: (index, text, mockUpdateTime) =>
            {
                var selectedLine = me.lines[index];
                
                if (selectedLine === undefined)
                {
                    throw "The requested line does not exist (LineHelper.update)!";
                }
                
                selectedLine.text = text + "";
                
                // If requested, update the given line.
                if (mockUpdateTime !== undefined)
                {
                    if (selectedLine.creationTime > mockUpdateTime)
                    {
                        selectedLine.creationTime = mockUpdateTime;
                    }
                    
                    selectedLine.setModifiedTime(mockUpdateTime);
                }
            },
            
            remove: (index) =>
            {
                if (me.lines[index])
                {
                    me.lines[index].flaggedForRemoval = true;
                }
            }
        };
        
        return result;
    };

    this.saveState = function(doNotAddToStack)
    {
        var saveState = {};
        saveState.content = me.getText(); // TODO: Make this faster.
        saveState.viewOffset = me.viewOffset * 1;
        saveState.editable = me.editable;
        saveState.highlighter = me.syntaxSelector.getDefaultHighlighter();

        if (!doNotAddToStack)
        {
            me.stateSaves.push(saveState);
        }
        
        return saveState;
    };

    this.restoreState = function(lastState)
    {
        lastState = lastState || me.stateSaves.pop();

        if (lastState !== undefined)
        {
            me.clear();
            me.displayContent(lastState.content);
            me.viewOffset = lastState.viewOffset;
            me.editable = lastState.editable;
            me.syntaxSelector.setDefaultHighlighter(lastState.highlighter);

            me.refreshPassedLines(0);
        }
    };

    this.setViewOffset = function(newOffset)
    {
        var oldOffset = me.viewOffset;

        me.viewOffset = newOffset;

        me.refreshPassedLines(oldOffset);
    };

    this.setEditable = function(newEditable)
    {
        me.editable = newEditable;
    };

    this.handleKey = function(key, ignoreSpecial)
    {
        var previous = undefined,
            next = undefined;

        var i;



        for (i = 0; i < me.lines.length; i++)
        {
            me.lines[i].prepareToHandleKey();
        }

        for (i = 0; i < me.lines.length; i++)
        {
            next = i + 1 < me.lines.length ? me.lines[i + 1] : undefined;

            me.lines[i].handleKey(key, previous, next, i, ignoreSpecial);

            previous = me.lines[i];
        };

        me.removeLinesFlaggedForRemoval();

        for (i = 0; i < me.lines.length; i++)
        {
            me.lines[i].afterHandleKey(i);
        }
    };

    this.removeLinesFlaggedForRemoval = function()
    {
        var newLines = [];
        for (let i = 0; i < me.lines.length; i++)
        {
            if (!me.lines[i].flaggedForRemoval)
            {
                newLines.push(me.lines[i]);
            }
            else if (me.trackRemoved)
            {
                me.removed.push([(new Date()).getTime(), i]);
            }
        }

        me.lines = newLines;
    };

    this.handleClick = function(point)
    {
        var viewOffset = me.viewOffset, x = me.x;
        for (var i = 0; i < me.lines.length; i++)
        {
            me.lines[i].x = x;
            me.lines[i].handleClick(i, point, i + viewOffset);
        }
    };

    this.addLine = function(index, content)
    {
        me.ctx.font = me.font;

        var newLine = new Line(me.ctx, me, me.x, me.y + index * me.lineH, me.lineH, index);

        newLine.text = content;

        if (index < me.lines.length)
        {
            me.lines.splice(index, 0, newLine);
        }
        else
        {
            me.lines.push(newLine);
        }
        
        newLine.updateModifiedTime();

        return newLine;
    };

    this.appendLine = function(content)
    {
        return me.addLine(me.lines.length, content);
    };

    this.shiftViewIfNecessary = function(viewIndex)
    {
        var tIndex = viewIndex + me.viewOffset;

        var oldViewOffset = (me.viewOffset || 0) * 1;

        if (tIndex < 0)
        {
            me.viewOffset = -viewIndex;
            me.y = 0;
        }
        else if (me.lineH != 0 && tIndex > me.ctx.canvas.height / me.lineH - 1)
        {
            var maxLines = Math.floor(me.ctx.canvas.height / me.lineH) - 1;

            me.viewOffset = maxLines - viewIndex;

            me.y = 0;
        }

        var line = me.lines[viewIndex];
        var lenPreCursor = me.ctx.measureText(line.text.substring(0, line.cursorPosition)).width;

        if (lenPreCursor + me.x > me.ctx.canvas.width * 0.9)
        {
            me.x = me.ctx.canvas.width * 0.9 - lenPreCursor;
        }
        else if (me.x + lenPreCursor <= me.ctx.canvas.width * 0.05)
        {
            me.x = -lenPreCursor + me.ctx.canvas.width * 0.05;
        }

        me.refreshPassedLines(oldViewOffset);
    };

    this.render = function()
    {
        // TODO Find a better solution.
        if (me.ctx.canvas.clientHeight !== me.ctx.canvas.height || me.ctx.canvas.clientWidth !== me.ctx.canvas.width)
        {
            me.ctx.canvas.height = me.ctx.canvas.clientHeight;
            me.ctx.canvas.width = me.ctx.canvas.clientWidth;
        }

        me.ctx.clearRect(0, 0, me.ctx.canvas.width, me.ctx.canvas.height);

        me.ctx.font = me.font;
        me.ctx.textBaseline = "top";
        me.lineH = me.ctx.measureText("M").width * 1.5;

        var i;

        for (i = -me.viewOffset; i < me.lines.length; i++)
        {
            me.lines[i].x = me.x;
            me.lines[i].h = me.lineH;
            me.lines[i].render(i + me.viewOffset, i);

            if (me.lines[i].y > me.ctx.canvas.height)
            {
                break;
            }
        }
    };

    this.getCursorPosition = function()
    {
        for (var i = 0; i < me.lines.length; i++)
        {
            if (me.lines[i].hasFocus)
            {
                return new Point(me.lines[i].cursorPosition, i);
            }
        }

        return new Point(-1, -1);
    };

    var oldSelStart, oldSelEnd;

    this.deselect = function()
    {
        if (oldSelStart == undefined && oldSelEnd == undefined)
        {
            return false;
        }

        var startIndex = 0;
        var endIndex = me.lines.length;

        if (oldSelStart)
        {
            startIndex = oldSelStart.y;
        }

        if (oldSelEnd)
        {
            endIndex = oldSelEnd.y + 1;
        }

        for (var i = startIndex; i < endIndex; i++)
        {
            if (me.lines[i])
            {
                me.lines[i].deselect();
            }
        }

        oldSelStart = undefined;
        oldSelEnd = undefined;
    };

    this.select = function(point1, point2)
    {
        var i;

        if (point1 === undefined && point2 === undefined)
        {
            for (i = 0; i < me.lines.length; i++)
            {
                me.lines[i].select();
            }

            if (me.lines.length > 0)
            {
                oldSelStart = { line: me.lines[0], y: 0 };
                oldSelEnd = { line: me.lines[me.lines.length - 1], y: me.lines.length - 1 };
            }

            return;
        }

        if (point1.y > point2.y)
        {
            var temp = point1;
            point1 = point2;
            point2 = temp;
        }

        var x1 = point1.x,
            y1 = point1.y,
            x2 = point2.x,
            y2 = point2.y;

        if (x1 < 0 || x2 < 0 || y1 >= me.lines.length
             || y1 < 0 || y2 < 0 || y2 >= me.lines.length)
        {
            return;
        }

        if (y1 === y2)
        {
            var line = me.lines[y1];

            if (x2 < x1)
            {
                var temp = x1;
                x1 = x2;
                x2 = temp;
            }

            line.select(x1, x2);

            oldSelStart = { line: line, y: y1 };
            oldSelEnd = { line: line, y: y2 };

            return;
        }

        var firstLine = me.lines[y1];
        var secondLine = me.lines[y2];
        firstLine.select(x1, firstLine.text.length);
        secondLine.select(0, x2);

        oldSelStart = { line: firstLine, y: y1 };
        oldSelEnd = { line: secondLine, y: y2 };

        for (var i = y1 + 1; i < y2; i++)
        {
            me.lines[i].select();
        }
    };

    this.getSelExtreme = function(direction, oldSelectionObj)
    {
        var result = undefined;

        if (oldSelectionObj && oldSelectionObj.line && oldSelectionObj.line.hasSelection())
        {
            result = {x: oldSelectionObj.line.selRange[direction === 1 ? 0 : 1] || 0, y: oldSelectionObj.y};
        }
        else
        {
            let startY = direction === 1 ? 0 : (me.lines.length - 1);
            let selRangeIndex = direction === 1 ? 0 : 1;

            for (var i = startY; (i < me.lines.length && direction === 1) || (i >= 0 && direction === -1); i += direction)
            {
                if (me.lines[i].hasSelection())
                {
                    result = {x: me.lines[i].selRange[selRangeIndex], y: i};

                    break;
                }
            }
        }

        return result || me.getCursorPosition();
    };

    this.getSelStart = function()
    {
        return me.getSelExtreme(1, oldSelStart);
    };

    this.getSelEnd = function()
    {
        return me.getSelExtreme(-1, oldSelEnd);
    };

    this.getSelectedText = function()
    {
        var result = "";
        var isFirst = true;

        for (var i = 0; i < me.lines.length; i++)
        {
            if (me.lines[i].hasSelection())
            {
                result += isFirst ? "" : '\n';

                result += me.lines[i].getSelectedText();

                isFirst = false;
            }
        }

        return result;
    };

    this.applyToSelection = function(functionToApply)
    {
        let firstLine = me.getSelStart();
        let lastLine = me.getSelEnd();

        for (var i = firstLine.y; i <= lastLine.y && i < me.lines.length; i++)
        {
            if (me.lines[i].hasSelection())
            {
                functionToApply(me.lines[i], i);
            }
        }
    };

    this.indentSelection = function(spaces)
    {
        let numberIndented = 0;

        me.applyToSelection(function(line, index)
        {
            line.indent(spaces || 4);

            numberIndented++;
        });

        return numberIndented;
    };

    this.deindentSelection = function(maxSpaces)
    {
        me.applyToSelection(function(line, index)
        {
            line.deindent(maxSpaces || 4);
        });
    };

    this.isCodeEditing = function()
    {
        return me.codeEditing;
    };

    this.clearSelectedText = function()
    {
        me.handleKey("");
    };

    this.clear = function(doNotResetView)
    {
        me.lines = [];

        if (!doNotResetView)
        {
            me.resetView();
        }
    };

    this.resetView = function()
    {
        me.viewOffset = 0;
        me.x = 0;
    };

    this.displayContent = function(content)
    {
        var textLines = (content || "undefined").split("\n");

        for (var i = 0; i < textLines.length; i++)
        {
            me.addLine(me.lines.length, textLines[i]);
        }
    };

    this.getText = function()
    {
        var result = "";

        for (var i = 0; i < me.lines.length; i++)
        {
            result += me.lines[i].text;

            if (i < me.lines.length - 1)
            {
                result += '\n';
            }
        }

        return result;
    };
    
    this.getDelta = function(savedState)
    {
        // TODO: Finish this.
        // savedState should contain a delta object.
        //This delta object contains the changes made,
        //a map from line IDs to changes to these lines.
        var lastDelta = savedState.delta || new Delta();
        var newDelta = new Delta(lastDelta);
        
        // When a delta is added to a line, it is merged with
        //previous deltas.
        for (var i = 0; i < me.lines.length; i++)
        {
            if (!lastDelta.hasLine(me.lines[i]))
            {
                newDelta.insertLine(i, me.lines[i]);
            }
            else if (me.lines[i].getLastTimeModified() > lastDelta.getCreationTime())
            {
                newDelta.updateLine(me.lines[i]);
            }
        }
        
        // Check for removals.
        // Binary search for the starting index.
        var startIndex = ListHelper.binarySearch(me.removed, (listItem) =>
        {
            return listItem[0] - lastDelta.getCreationTime();
        }, true);
        
        for (var i = startIndex; i < me.removed.length; i++)
        {
            newDelta.removeLine(me.removed[i][1], me.removed[i]);
        }
        
        return newDelta;
    };

    this.insert = function(textToInsert)
    {
        if (textToInsert.length < 50)
        {
            for (var i = 0; i < textToInsert.length; i++)
            {
                me.handleKey(textToInsert.charAt(i), true);
            }
        }
        else
        {
            var newText = "";
            var endingText = "";

            // Note that selStart and selEnd
            //default to the cursor's position if no text
            //is selected.
            var selStart = me.getSelStart();
            var selEnd = me.getSelEnd();
            var lastSelectedLine = me.lines[selEnd.y]; // The last line with selection, or the line with focus.

            // Add anything after the selection point to the endingText
            //accumulator (it should go after the inserted text).
            if (lastSelectedLine && lastSelectedLine.hasSelection())
            {
                endingText += lastSelectedLine.text.substring(lastSelectedLine.selRange[1]);
            }
            else if (lastSelectedLine && lastSelectedLine.hasFocus)
            {
                endingText += lastSelectedLine.text.substring(selEnd.x);
            }

            // Add the text to be inserted...
            newText += textToInsert;

            // Add any text remaining on the last, selected line.
            newText += endingText;

            // If inserting before the end, add a line-break.
            if (selEnd.y + 1 < me.lines.length)
            {
                newText += "\n";
            }

            // Find all unselected text...
            for (var i = selEnd.y + 1; i < me.lines.length; i++)
            {
                newText += me.lines[i].text;

                if (i + 1 < me.lines.length)
                {
                    newText += "\n";
                }
            }

            // Remove all lines from the end to the beginning of the selection.
            for (var i = me.lines.length - 1; i > selStart.y; i --)
            {
                me.lines.pop();
            }

            var firstSelectedLine = me.lines[selEnd.y];

            // Remove selected text on the first line.
            if (firstSelectedLine)
            {
                if (firstSelectedLine.hasSelection())
                {
                    firstSelectedLine.text = firstSelectedLine.text.substring(0, firstSelectedLine.selRange[0]);
                }
                else if (firstSelectedLine.hasFocus)
                {
                    firstSelectedLine.text = firstSelectedLine.text.substring(0, selStart.x);
                }
            }

            var firstLineBreak = newText.indexOf("\n");

            if (firstLineBreak === -1)
            {
                firstLineBreak = newText.length;
            }

            var firstLine = newText.substring(0, firstLineBreak);

            if (firstSelectedLine)
            {
                firstSelectedLine.text += firstLine;
            }
            else
            {
                me.appendLine(firstLine);
            }

            newText = newText.substring(firstLineBreak + 1);

            if (newText.length > 0)
            {
                me.displayContent(newText);
            }
        }
    };

    this.unfocus = function()
    {
        for (var i = 0; i < me.lines.length; i++)
        {
            me.lines[i].unfocus();
        }
    };

    this.focusFirstLine = function()
    {
        if (me.lines.length === 0)
        {
            me.appendLine("NO CONTENT");
        }

        me.lines[0].focus();
    }

    var currentRefreshLine = -1, currentEndLine;
    this.refreshPassedLines = function(oldViewOffset)
    {
        if (me.viewOffset < oldViewOffset)
        {
            let refreshRate = 20;
            
            var refreshLineLoop = function()
            {
                for (var i = 0; i < refreshRate; i++)
                {
                    if (currentRefreshLine > currentEndLine + 1 || currentRefreshLine > me.lines.length)
                    {
                        currentRefreshLine = -1;
                        
                        return;
                    }
                    
                    if (me.lines[currentRefreshLine])
                    {
                        me.lines[currentRefreshLine].refreshHighlitingIfNeeded(currentRefreshLine, false, true); // Don't force, but ignore timeouts.
                    }

                    currentRefreshLine++;
                }
                
                requestAnimationFrame(refreshLineLoop);
            };
            
            let newEndLine = Math.min(me.lines.length, -me.viewOffset);
            
            let newStartPosition = Math.max(0, -oldViewOffset);
            
            if (newStartPosition > newEndLine)
            {
                return;
            }
            
            if (currentRefreshLine === -1)
            {
                currentRefreshLine = newStartPosition;
                currentEndLine = newEndLine;
                
                refreshLineLoop();
            }
            else
            {
                currentRefreshLine = Math.min(currentRefreshLine, newStartPosition);
                currentEndLine = Math.max(newEndLine, currentEndLine);
            }
        }
    };

    this.moveView = function(dx, dy)
    {
        var oldViewOffset = me.viewOffset;

        me.x += dx;

        var sign = dy > 0 ? 1 : -1;

        if (dy === 0 || me.lineH === 0)
        {
            return;
        }

        dy = Math.abs(dy);

        var total = Math.abs(dy + me.y * sign) / me.lineH;
        var dlines = Math.floor(total);
        me.y = (total - dlines) * sign * me.lineH;
        me.viewOffset += dlines * sign;

        var viewOffsetOld = me.viewOffset*1;

        me.viewOffset = -Math.min(me.lines.length - 1, -me.viewOffset);
        me.viewOffset = Math.min(0, me.viewOffset);

        if (viewOffsetOld !== me.viewOffset || me.viewOffset > -1)
        {
            me.y = 0;
        }

        me.x = Math.min(me.x, me.ctx.canvas.width/2);

        me.refreshPassedLines(oldViewOffset);
    };

    var firstLine = this.addLine(0, "[[ JSEdit v. " + VERSION_CODE + " ]]");
    firstLine.hasFocus = true;
    firstLine.cursorPosition = firstLine.text.length;

    firstLine.select();
}

function Editor(textViewerParentElement, keyboardParentElement, 
    textExportParentElement, runFrameParentElement, onRun)
{
    const me = this;

    onRun = onRun || function() {};

    // Assign parent elements based on arguments.
    if (textViewerParentElement && !keyboardParentElement && !textExportParentElement
        && !runFrameParentElement)
    {
        keyboardParentElement = textViewerParentElement;
        textExportParentElement = textViewerParentElement;
        runFrameParentElement = textViewerParentElement;
    }

    me.hiddenControls = [];

    if (!keyboardParentElement)
    {
        keyboardParentElement = document.createElement("div");

        me.hiddenControls.push(keyboardParentElement);
    }

    if (!textExportParentElement)
    {
        textExportParentElement = document.createElement("div");

        me.hiddenControls.push(textExportParentElement);
    }

    if (!runFrameParentElement)
    {
        runFrameParentElement = document.createElement("div");

        me.hiddenControls.push(runFrameParentElement);
    }

    this.timeToRepeatKey = 500;
    this.dtRepeatKey = 150;

    this.saveDir = undefined;

    this.copyPasteControl = document.createElement("textarea");
    this.runFrame = document.createElement("iframe");
    this.runFrame.style.display = "none";
    var canUseLocalStorage = true;

    try
    {
        if (window.localStorage)
        {
            this.copyPasteControl.value = window.localStorage.getItem("save") || "N/A";
        }
        else
        {
            canUseLocalStorage = false;
        }
    }
    catch(e)
    {
        canUseLocalStorage = false;
    }

    this.editCanvas = document.createElement("canvas");
    this.editCanvas.style.touchAction = "none";
    this.editCanvas.style.border = "0px solid black";
    this.editCanvas.style.outline = "none";

    this.editCtx = this.editCanvas.getContext("2d");
    this.editControl = new EditControl(this.editCtx);

    this.keyCanvas = document.createElement("canvas");
    this.keyCtx = this.keyCanvas.getContext("2d");

    var displayingInfo = false;
    var findReplaceEnabled = false;

    this.clipboard = "";

    this.getPreUnloadSaveString = function()
    {
        var result =
        JSON.stringify(
        {
            text: me.editControl.getText(),
            viewOffset: me.editControl.viewOffset,
            path: me.saveDir
        });

        return result;
    };

    const updateRestoreString = function()
    {
        if (window.app)
        {
            var changes = me.getPreUnloadSaveString();

            window.app.setRestoreString(changes);
        }
    };

    this.loadFromSaveString = function(saveString)
    {
        // Check for prefixing...
        if (saveString.length > 1 && saveString.charAt(0) != "L" && saveString.charAt(1) != "L")
        {
            var data = JSON.parse(saveString);

            if (typeof data == "string")
            {
                data = JSON.parse(data);
            }

            me.clear();

            me.displayContent(data["text"] || ("GOT: " + saveString + "\nParsed: " + JSON.stringify(data)));

            // If the data has a save directory, note this.
            if (data["path"] && data["path"] !== "undefined")
            {
                me.saveDir = data["path"];

                // Infer the highlight scheme.
                if (me.saveDir.lastIndexOf(".") !== -1)
                {
                    me.editControl.setDefaultHighlightScheme(me.saveDir.substring(me.saveDir.lastIndexOf(".") + 1));
                }
            }

            if (data["viewOffset"])
            {
                me.editControl.setViewOffset(parseFloat(data["viewOffset"]));
            }

            me.editControl.render();
        }
        else
        {
            me.clear();
            
            me.displayContent(saveString.substring(1)); // Non-JSON saves are prefixed. Remove this prefix.
            
            me.editControl.render();
        }
    };

    this.load = function()
    {
        if ((window.app && (me.copyPasteControl.style.display === "none" || me.copyPasteControl.value === "")) || me.saveDir)
        {
            var onComplete = function()
            {
                me.clear();
                me.displayContent(app.getFileContent(me.saveDir) || "NO CONTENT FOUND FOR `" + me.saveDir + "`.");

                if (me.saveDir.lastIndexOf(".") !== -1)
                {
                    me.editControl.setDefaultHighlightScheme(me.saveDir.substring(me.saveDir.lastIndexOf(".") + 1));
                }

                me.editControl.focusFirstLine();

                me.editControl.render();
            };

            if (!me.saveDir)
            {
                me.selectFile(me.saveDir, function()
                {
                    onComplete();
                });
            }
            else
            {
                onComplete();
            }
        }
        else
        {
            me.copyPasteControl.select();
            document.execCommand("paste");

            requestAnimationFrame(function()
            {
                me.clear();
                me.displayContent(me.copyPasteControl.value);

                me.editControl.focusFirstLine();

                me.editControl.render();
            });
        }
    };

    this.save = function()
    {
        var text = me.editControl.getText();

        if (!me.saveDir)
        {

            if (canUseLocalStorage && window.localStorage)
            {
                window.localStorage.setItem("save", text);
            }

            me.copyPasteControl.select();
            me.copyPasteControl.style.display = "block";

            me.copyPasteControl.value = text;

            requestAnimationFrame(function()
            {
                document.execCommand("copy");
            });
        }
        else
        {
            me.copyPasteControl.style.display = "none";

            var resultNotes = app.writeToFile(me.saveDir, text);

            if (resultNotes !== "SUCCESS")
            {
                me.editControl.saveState();
                me.editControl.clear();
                me.editControl.setEditable(false);
                me.editControl.displayContent("Error: `" + resultNotes + "`.");

                setTimeout(() =>
                {
                    me.editControl.restoreState();
                }, 2000);
            }
        }
    };


    var lastSelPoint = undefined;
    this.keyboard = new Keyboard(this.keyCtx, function(key)
    {
        if (key == "üìÇ")
        {
            me.load();
        }
        else if (key == "üíæ")
        {
            me.save();
        }
        else if (key == "üóÇÔ∏è")
        {
            me.selectFile(me.saveDir);
        }
        else if (key == "‚öôÔ∏è")
        {
            me.advancedOptions();
        }
        else if (key == "üìå")
        {
            var currentPoint = me.editControl.getCursorPosition();

            if (lastSelPoint)
            {

 me.editControl.select(lastSelPoint, currentPoint);
                lastSelPoint = undefined;
            }
            else
            {
                lastSelPoint = currentPoint;
            }
        }
        else if (key === "üìú" || key === "‚úÇÔ∏è")
        {
            me.clipboard = me.editControl.getSelectedText();

            if (key === "‚úÇÔ∏è")
            {
                me.editControl.clearSelectedText();
            }
        }
        else if (key === "üìã")
        {
            me.editControl.insert(me.clipboard);
        }
        else if (key === "‚öú")
        {
            me.editControl.codeEditing = !me.editControl.codeEditing;
        }
        else if (key === "‚ûï")
        {
            me.editControl.indentSelection();
        }
        else if (key === "‚ûñ")
        {
            me.editControl.deindentSelection();
        }
        else if (key === "‚Ñπ")
        {
            if (!displayingInfo)
            {
                var textContent = me.editControl.getText();
                var linesCount = me.editControl.lines.length;
                me.editControl.saveState();
                me.editControl.clear();

                me.editControl.setEditable(false);

                me.editControl.displayContent(`
Information:
Length: ` + textContent.length + ` characters.
Lines: ` + linesCount + `.
File Access: ` + (window.app !== undefined) + `.
Path: ${ me.saveDir }
`);
            }
            else
            {
                me.editControl.restoreState();
            }

            displayingInfo = !displayingInfo;
        }
        else if (key === "üîé")
        {
            me.toggleFindReplace();
        }
        else if (key === "üöò")
        {
            me.toggleRun();
        }
        else
        {
            me.editControl.handleKey(key);
        }

        me.editControl.render();

        updateRestoreString();
    });

    this.keyCanvas.onclick = function(e, noReRender)
    {
      try
      {
        var bbox = me.keyCanvas.getBoundingClientRect();

        var x = e.clientX - bbox.left;
        var y = e.clientY - bbox.top;

        me.keyboard.handleClick(new Point(x, y));

        if (!noReRender)
        {
            me.keyboard.render();
        }
      }
      catch(e)
      {
        noteError(e);
      }
    };

    var pointerDownTime, pointerDown = false;
    me.keyCanvas.onpointerdown = function(e)
    {
        pointerDownTime = (new Date()).getTime();
        pointerDown = true;

        var dt = me.dtRepeatKey;

        var lastTime = (new Date()).getTime();
        var clickLoop = function()
        {
            if (!pointerDown)
            {
                return;
            };

            var nowTime = (new Date()).getTime();

            if (nowTime - pointerDownTime > me.timeToRepeatKey && nowTime - lastTime > dt)
            {
                for (var i = 0; i < (nowTime - lastTime) / dt && i < 10; i++)
                {
                    me.keyCanvas.onclick(e, true);
                }

                me.keyboard.render();

                dt *= 0.95;

                lastTime = nowTime;
            }

            requestAnimationFrame(clickLoop);
        };

        clickLoop();
    };

    me.keyCanvas.onpointercancel = function()
    {
        pointerDown = false;

        me.editCanvas.focus();
    };

    me.keyCanvas.onpointerleave = me.keyCanvas.onpointercancel;
    me.keyCanvas.onpointerup = me.keyCanvas.onpointercancel;

    me.editCanvas.onclick = function(e)
    {
      try
      {
        var bbox = me.editCanvas.getBoundingClientRect();

        var x = e.clientX - bbox.left;
        var y = e.clientY - bbox.top;

        me.editControl.handleClick(new Point(x, y));

        me.editControl.render();
      }
      catch(e)
      {
        noteError(e);
      }
    };

    var editPointerDown = false;
    var lastEditPointerLocation;
    this.editCanvas.onpointerdown = function(e)
    {
        var bbox = me.editCanvas.getBoundingClientRect();
        lastEditPointerLocation = new Point(e.clientX - bbox.left, e.clientY - bbox.top);

        editPointerDown = true;

        e.preventDefault();

        me.editCanvas.focus();

        return false;
    };

    this.editCanvas.addEventListener("pointermove", function(e)
    {
        if (!editPointerDown)
        {
            return;
        }

        e.preventDefault();

        var bbox = me.editCanvas.getBoundingClientRect();
        var point = new Point(e.clientX - bbox.left, e.clientY - bbox.top);

        var dx = point.x - lastEditPointerLocation.x;
        var dy = point.y - lastEditPointerLocation.y;

        var xSign = dx > 0 ? 1 : -1;
        var ySign = dy > 0 ? 1 : -1;

        me.editControl.moveView(dx * 2, dy * dy * ySign / 2);
        me.editControl.render();

        lastEditPointerLocation = point;

        return true;
    }, true);

    this.editCanvas.onpointerup = function(e)
    {
        editPointerDown = false;

        e.preventDefault();
    };

    this.editCanvas.onpointercancel = me.editCanvas.onpointerup;

    this.editCanvas.onpointerleave = me.editCanvas.onpointerup;

    this.editCanvas.addEventListener("keypress", function(event)
    {
        if (!event.ctrlKey && event.key !== "Enter")
        {
            me.editControl.handleKey(event.key);
        }

        me.editControl.render();

        event.preventDefault();

        updateRestoreString();
    }, true);

    this.editCanvas.addEventListener("wheel", function(event)
    {
        var dy = event.deltaY;

        event.preventDefault();

        if (dy !== 0)
        {
            me.editControl.moveView(0, dy * 10);
        }

        me.editControl.render();
    });
    
    var undoStates = [];
    var redoStates = [];

    this.editCanvas.addEventListener("keydown", function(event)
    {
        if (!event.shiftKey)
        {
            if (event.key === "ArrowDown" || event.key === "ArrowUp" || event.key === "ArrowLeft"
                    || event.key === "ArrowRight" || event.key === "Backspace" || event.key === "Tab")
            {
                requestAnimationFrame(() =>
                {
                    let indentCount = 0;

                    if (event.key === "Tab")
                    {
                        indentCount = me.editControl.indentSelection();
                    }

                    if (event.key !== "Backspace")
                    {
                        me.editControl.deselect();
                    }
                    
                    if (indentCount === 0)
                    {
                        me.editControl.handleKey(event.key);
                    }

                    me.editControl.render();
                });

                event.preventDefault();

                return true;
            }
        }
        else if (event.key === "ArrowDown" || event.key === "ArrowUp" || event.key === "ArrowLeft" || event.key === "ArrowRight")
        {
            var selStart = me.editControl.getSelStart();
            var selEnd = me.editControl.getSelEnd();

            me.editControl.handleKey(event.key);

            var cursorPosition = me.editControl.getCursorPosition();

            if (cursorPosition.x === selStart.x && cursorPosition.y === selStart.y && selStart.x > 0)
            {
                selStart.x -= 1;
            }
            else if (cursorPosition.y < selStart.y || (cursorPosition.y === selStart.y && cursorPosition.x < selStart.x))
            {
                selStart = cursorPosition;
            }
            else if (cursorPosition.y > me.selEnd || (cursorPosition.y === selEnd.y && cursorPosition.x > selEnd.x))
            {
                selEnd = cursorPosition;
            }
            else
            {
                var dyToStart = Math.abs(cursorPosition.y - selStart.y),
                    dyToEnd = Math.abs(cursorPosition.y - selEnd.y),
                    dxToStart = Math.abs(cursorPosition.x - selStart.x),
                    dxToEnd = Math.abs(cursorPosition.x - selEnd.x);

                // If closer to the starting selection...
                if (dyToStart < dyToEnd || (dyToStart == dyToEnd && dxToStart < dxToEnd))
                {
                    selStart = cursorPosition;
                }
                else
                {
                    selEnd = cursorPosition;
                }
            }

            me.editControl.deselect();
            me.editControl.select(selStart, selEnd);

            me.editControl.render();
            event.preventDefault();
        }

        // Handle control-key commands.
        if (event.key === "Enter")
        {
            me.editControl.handleKey(event.key);

            me.editControl.render();
            event.preventDefault();
        }
        else if (event.ctrlKey)
        {
            if (event.key === "c" || event.key === "x")
            {
                me.clipboard = me.editControl.getSelectedText();

                if (event.key === "x")
                {
                    me.editControl.clearSelectedText();
                }

                me.editControl.deselect();
            }
            else if (event.key === "v")
            {
                me.editControl.insert(me.clipboard);

                me.editControl.deselect();
            }
            else if (event.key === "f")
            {
                me.toggleFindReplace();
            }
            else if (event.key === "s")
            {
                me.save();
            }
            else if (event.key === "r") // Reads the file.
            {
                me.load();
            }
            else if (event.key === "o" && window.app) // Reads the file.
            {
                me.selectFile(me.saveDir);
            }
            else if (event.key === "g")
            {
                me.advancedOptions();
            }
            else if (event.key === "u")
            {
                me.editControl.deselect();
            }
            else if (event.key === "z" || event.key === "b")
            {
                if (undoStates.length === 0 || event.key === "b")
                {
                    undoStates.push(me.editControl.saveState(true));
                }
                else
                {
                    var stateToRestoreTo = undoStates.pop();
                    
                    undoStates.push(me.editControl.saveState(true));
                    
                    me.editControl.restoreState(stateToRestoreTo);
                }
            }
            else if (event.key === "d")
            {
                me.editControl.deindentSelection();
            }
            else if (event.key === "a")
            {
                me.editControl.select();
            }
            else if (event.key === "e") // Execute the program.
            {
                me.toggleRun();
            }

            me.editControl.render();
            event.preventDefault();
        }

        updateRestoreString();
    }, true);

    this.editCanvas.setAttribute('tabindex', 0);

    this.toggleRun = function()
    {
        if (me.runFrame.style.display === "block")
        {
            me.runFrame.style.display = "none";
            me.runFrame.src = "data:text/html;charset=UTF-8,Loading...";
        }
        else
        {
            var contentToRun = me.editControl.getText();

            runFrameParentElement.removeChild(me.runFrame);

            me.runFrame = document.createElement("iframe");
            me.runFrame.style.backgroundColor = "white";
            me.runFrame.style.display = "block";

            runFrameParentElement.appendChild(me.runFrame);

            if (!onRun(contentToRun, me.runFrame))
            {
                me.runFrame.contentWindow.document.open();
                me.runFrame.contentWindow.document.write(contentToRun);
                me.runFrame.contentWindow.document.close();
            }

            if (runFrameParentElement === textViewerParentElement)
            {
                me.runFrame.width = me.editCanvas.width;
                me.runFrame.height = me.editCanvas.height;
            }
            else
            {
                me.runFrame.style.width = "calc(100% - 10px)";
                me.runFrame.style.height = "calc(100% - 10px)";
            }
        }
    };

    var viewingAdvancedOptions = false;
    this.advancedOptions = function()
    {
        if (viewingAdvancedOptions)
        {
            viewingAdvancedOptions = false;
            
            me.editControl.restoreState();
            
            return;
        }
        
        me.editControl.saveState();
        me.editControl.clear();
        
        viewingAdvancedOptions = true;

        var titleLine = me.editControl.appendLine("Advanced Options:");
        titleLine.editable = false;

        var loadEditorSource = me.editControl.appendLine("Load Editor's Source");
        loadEditorSource.editable = false;

        var setFont = me.editControl.appendLine("Font: " + me.editControl.font);

        var selectHighlightScheme = me.editControl.appendLine("Select Coloring Scheme");
        selectHighlightScheme.editable = false;

        var shareAsTextLine = window.app ? me.editControl.appendLine("Share as Text") : null;
        var shareAsHTMLTextLine = window.app ? me.editControl.appendLine("Share as HTML Text") : null;

        var setPathToSpellingDictionary = window.app ? me.editControl.appendLine("Set Path to Spellcheck Dictionary") : null;
        var runSpellCheck = window.app ? me.editControl.appendLine("Check Spelling") : null;
        
        var checkSyntax = me.editControl.appendLine("Check Syntax");
        checkSyntax.editable = false;

        var exitLine = me.editControl.appendLine("Hide Advanced Options");
        exitLine.editable = false;

        exitLine.focus();

        const exitAdvancedOptions = () =>
        {
            me.editControl.restoreState();
            viewingAdvancedOptions = false;
        };

        exitLine.onentercommand = function()
        {
            exitAdvancedOptions();
        };

        loadEditorSource.onentercommand = function()
        {
            exitAdvancedOptions();

            me.saveDir = undefined;

            me.editControl.clear();

            me.editControl.displayContent(EDITOR_SOURCE);

            me.editControl.setDefaultHighlightScheme("html");
        };

        selectHighlightScheme.onentercommand = function()
        {
            me.editControl.clear();

            var handleLine = function(schemeLabel)
            {
                var newLine = me.editControl.appendLine("Apply: " + schemeLabel);

                newLine.onentercommand = function()
                {
                    exitAdvancedOptions();

                    me.editControl.setDefaultHighlightScheme(SyntaxHelper.highlighters[schemeLabel]);
                };
            };

            for (var label in SyntaxHelper.highlighters)
            {
                handleLine(label);
            }

            var cancelLine = me.editControl.appendLine("Cancel");

            cancelLine.editable = false;

            cancelLine.onentercommand = function()
            {
                exitAdvancedOptions();
            };

            requestAnimationFrame(function()
            {
                cancelLine.focus();
            });
        };

        setFont.onentercommand = function()
        {
            let lineText = setFont.text;

            if (lineText && lineText.indexOf(": ") !== -1)
            {
                me.editControl.font = lineText.substring(lineText.indexOf(": ") + 2);
            }
        };
        
        checkSyntax.onentercommand = function()
        {
            exitAdvancedOptions();
            
            me.toggleSyntaxCheck();
        };

        if (setPathToSpellingDictionary != undefined)
        {
            setPathToSpellingDictionary.onentercommand = function()
            {
                exitAdvancedOptions();

                me.saveDir = app.getInternalStorageDirectory() + "/spellcheck.txt";
            };
        }

        if (runSpellCheck != undefined)
        {
            runSpellCheck.onentercommand = function()
            {
                exitAdvancedOptions();

                me.spellCheck();
            };
        }

        if (shareAsTextLine != undefined && shareAsHTMLTextLine != undefined)
        {
            // TODO Reduce code duplication.
            shareAsTextLine.onentercommand = function()
            {
                exitAdvancedOptions();

                // Send the text.
                window.app.shareAsText(me.editControl.getText());
            };

            shareAsHTMLTextLine.onentercommand = function()
            {
                exitAdvancedOptions();

                // Send the HTML-based text.
                window.app.shareAsHTMLText(me.editControl.getText());
            };
        }
    };
    
    var checkingSyntax = false;
    this.toggleSyntaxCheck = function()
    {
        if (checkingSyntax)
        {
            me.editControl.restoreState();
        }
        else
        {
            var text = me.editControl.getText().split("\n");
            var syntaxChecker = new SyntaxChecker();
        
            me.editControl.saveState();
            me.editControl.clear();
            
            var exitLine = me.editControl.appendLine("Exit");
            exitLine.focus();
            
            exitLine.onentercommand = function()
            {
                me.toggleSyntaxCheck();
            };
            
            syntaxChecker.reset();
            
            //console.log(text);
            
            for (var lineNumber = 0; lineNumber < text.length - 1; lineNumber++)
            {
                syntaxChecker.checkLine(text[lineNumber], lineNumber, false, {});
            }
            
            if (text.length - 1 >= 0)
            {
                syntaxChecker.checkFinalLine(text[text.length - 1], text.length - 1, {});
            }
            
            var problems = syntaxChecker.getProblems();
            
            var handleProblem = (problem) =>
            {
                var newLine = me.editControl.appendLine(problem.lineNumber + ": " + (problem.message || problem.check + " failed. No message."));
                
                newLine.onentercommand = function()
                {
                    me.toggleSyntaxCheck();
                    me.editControl.lines[problem.lineNumber].focus();
                };
            };
            
            for (var i = 0; i < problems.length; i++)
            {
                handleProblem(problems[i]);
            }
        }
        
        checkingSyntax = !checkingSyntax;
    };

    this.spellCheck = function()
    {
        var textToCheck = me.editControl.getText();
        var wordsToCheck = me.editControl.getText().split(/[ \t\n.;!?=0-9]/g);

        me.editControl.saveState();

        me.editControl.clear();

        var spellingDictionaryPath = app.getInternalStorageDirectory() + "/spellcheck.txt";

        var wordsJoined = app.getFileContent(spellingDictionaryPath) || "if";
        var checkAgainstWords = wordsJoined.split(/[ \t\n.?!;?=0-9\<\>\-_\=\+\'\"\`\[\]\(\)\\\/\{\}\:\|]/g);

        var filteredWords = [];

        for (var i = 0; i < checkAgainstWords.length; i++)
        {
            if (checkAgainstWords[i] !== "")
            {
                filteredWords.push(checkAgainstWords[i].toUpperCase());
            }
        }

        filteredWords.sort();

        var findWord = function (word, precision, startIndex, endIndex, depth, returnClosest)
        {
            endIndex = endIndex !== undefined ? endIndex : filteredWords.length;
            startIndex = startIndex !== undefined ? startIndex : 0;
            let checkIndex = Math.floor((startIndex + endIndex) / 2);
            depth = depth || 0;

            let compareTo = filteredWords[checkIndex];

            var currentPrecision = precision || Math.max(word.length, compareTo.length);

            if (depth > 22)
            {
                return returnClosest ? checkIndex : false;
            }

            if (word.substring(0, currentPrecision).toUpperCase() === compareTo.substring(0, currentPrecision).toUpperCase())
            {
                return compareTo;
            }
            else if (startIndex !== checkIndex && word.toUpperCase() > compareTo.toUpperCase())
            {
                startIndex = checkIndex;

                return findWord(word, precision, startIndex, endIndex, depth + 1, returnClosest);
            }
            else if (startIndex !== checkIndex)
            {
                endIndex = checkIndex;

                return findWord(word, precision, startIndex, endIndex, depth + 1, returnClosest);
            }

            return returnClosest ? checkIndex : false;
        };

        var getSuggestions = function(word, checkedWords)
        {
            let iterations = 1, foundWord, suggestions = [];
            let centerIndex = findWord(word, undefined, undefined, undefined, undefined, true);
            let currentIndex = centerIndex;
            
            checkedWords = checkedWords || {};

            while (suggestions.length < 4 && currentIndex >= 0 && currentIndex < filteredWords.length)
            {
                foundWord = filteredWords[currentIndex];
                
                if (foundWord && !checkedWords[foundWord])
                {
                    suggestions.push(foundWord);
                    checkedWords[foundWord] = true;
                }

                iterations++;
                
                if (iterations % 2 === 0)
                {
                    currentIndex = centerIndex + iterations / 2;
                }
                else
                {
                    currentIndex = centerIndex - Math.floor(iterations / 2);
                }
            }

            if (word.length > 3 && suggestions.length < 16)
            {
                let newWord = word.substring(1);
                
                suggestions = suggestions.concat(getSuggestions(newWord, checkedWords));
            }

            return suggestions;
        };

        var buffer = "";
        var currentChar;
        var errors = {};
        var errorsCount = 0;

        for (var i = 0; i < textToCheck.length; i++)
        {
            currentChar = textToCheck.charAt(i);

            if (currentChar.toUpperCase() >= 'A' && currentChar.toUpperCase() <= 'Z')
            {
                buffer += currentChar;
            }
            else if (currentChar === " " || currentChar === "\n" || currentChar === "-" || currentChar === "\t")
            {
                if (!findWord(buffer) && buffer.length > 0)
                {
                    errors[i] = buffer;

                    errorsCount++;
                }

                buffer = "";
            }
            else
            {
                buffer = "";
            }
        }

        var handleNewLine = function(errorIndex, word)
        {
            var newLine = me.editControl.appendLine("[-] " + word + " at " + errorIndex + ". ");
            newLine.editable = false;

            newLine.onentercommand = function()
            {
                me.editControl.clear();

                me.editControl.appendLine("Suggestions for " + word + ".");
                var addToDictionaryLine = me.editControl.appendLine("Add " + word + " to dictionary.");
                addToDictionaryLine.editable = false;
                var cancelLine = me.editControl.appendLine("~~CANCEL~~");
                cancelLine.editable = false;

                cancelLine.focus();

                cancelLine.onentercommand = function()
                {
                    me.editControl.clear();

                    addLines();
                };

                addToDictionaryLine.onentercommand = function()
                {
                    var writeText = wordsJoined + "\n" + word;

                    wordsJoined = writeText;
                    delete errors[errorIndex];

                    var result = app.writeToFile(spellingDictionaryPath, writeText);

                    if (result !== "SUCCESS")
                    {
                        noteError(result);
                    }
                    else
                    {
                        cancelLine.onentercommand();
                    }
                };

                var handleSuggestion = function(suggestionText)
                {

                    if (word.toLowerCase() === word)
                    {
                        suggestionText = suggestionText.toLowerCase();
                    }
                    else if (suggestionText.length > 0
                            && word.length > 1 && word.charAt(0) === word.charAt(0).toUpperCase() && word.substring(1).toLowerCase() === word.substring(1))
                    {
                        suggestionText = suggestionText.charAt(0).toUpperCase() + suggestionText.substring(1).toLowerCase();
                    }
                    else if (word.toUpperCase() !== word)
                    {
                        suggestionText = suggestionText.toLowerCase();
                        let suggestionTextNew = "";

                        for (let i = 0; i < word.length && i < suggestionText.length; i++)
                        {
                            suggestionTextNew += (word.charAt(i).toUpperCase() === word.charAt(i)) ? suggestionText.charAt(i).toUpperCase() : suggestionText.charAt(i);
                        }

                        suggestionText = suggestionTextNew + suggestionText.substring(suggestionTextNew.length);
                    }

                    var suggestionLine = me.editControl.appendLine(" " + suggestionText);

                    suggestionLine.onentercommand = function()
                    {
                        textToCheck = textToCheck.substring(0, errorIndex) + suggestionText + textToCheck.substring(errorIndex + word.length);

                        delete errors[errorIndex];

                        cancelLine.onentercommand();
                    };
                };

                var suggestions = getSuggestions(word);

                for (var j = 0; j < suggestions.length; j++)
                {
                    handleSuggestion(suggestions[j]);
                }
            };
        };

        var addLines = function()
        {
            var exitLine = me.editControl.appendLine("Exit (" + filteredWords.length + " to be checked)...");
            exitLine.editable = false;

            var errorsCountDisplay = me.editControl.appendLine("Found " + errorsCount + " errors.");
            errorsCountDisplay.editable = false;

            if (errorsCount > 0)
            {
                var addAllToDictionary = me.editControl.appendLine("Add All Errors to Dictionary");
                var addedWords = {};

                addAllToDictionary.editable = false;

                addAllToDictionary.onentercommand = function()
                {

                    var appendText = "";

                    for (var i in errors)
                    {
                        if (!addedWords[errors[i]])
                        {
                            addedWords[errors[i]] = true;

                            appendText += "\n" + errors[i].toUpperCase();
                        }
                    }

                    var writeText = wordsJoined + appendText;

                    var result = app.writeToFile(spellingDictionaryPath, writeText);

                    if (result !== "SUCCESS")
                    {
                        noteError(result);
                    }
                    else
                    {
                        exitLine.onentercommand();
                    }
                };
            }

            for (var errorIndex in errors)
            {
                handleNewLine(errorIndex, errors[errorIndex]);
            }

            exitLine.onentercommand = function()
            {
                me.editControl.restoreState();

                me.editControl.clear(true); // No view reset.
                me.displayContent(textToCheck);
            };
        };

        addLines();
    };

    var selectingFile = false;
    this.selectFile = function(basePath, onComplete)
    {
        basePath = basePath || "/";

        if (!selectingFile && window.app)
        {
            selectingFile = true;

            var getDirectory = (path) =>
            {
                return path.substring(0, path.lastIndexOf("/"));
            };

            var currentPath = basePath;

            me.editControl.saveState();
            me.editControl.clear();

            me.editControl.setEditable(true);

            var directoryLine = me.editControl.appendLine(currentPath);
            var submitLine = me.editControl.appendLine("Select");
            var runCommandLine = me.editControl.appendLine("%: ");
            var subPathLines = [];

            var clearSubPathLines = () =>
            {
                // Hide lines from the previous display of contents.
                for (var i = 0; i < subPathLines.length; i++)
                {
                    subPathLines[i].flaggedForRemoval = true;
                }

                me.editControl.removeLinesFlaggedForRemoval();

                subPathLines = [];
            };

            submitLine.editable = false;

            var listSubDirsAndFiles = (path) =>
            {
                clearSubPathLines();


                var directory = getDirectory(path);

                var filesList = (app.listFiles(directory) || "").split("\n");

                var handleLine = function(fileName)
                {
                    if (fileName === "")
                    {
                        return;
                    }
                    else if (fileName.endsWith("@"))
                    {
                        fileName = fileName.substring(0, fileName.length - 1) + "/";
                    }

                    var newLine = me.editControl.appendLine("> " + fileName);

                    newLine.onentercommand = function()
                    {
                        if (!fileName.startsWith(".."))
                        {
                            directoryLine.text = directory + "/" + fileName;
                        }
                        else
                        {
                            directoryLine.text = directory.substring(0, directory.lastIndexOf("/")) + "/";
                        }

                        listSubDirsAndFiles(directoryLine.text);

                        if (!fileName.endsWith("/"))
                        {
                            submitLine.focus();
                        }
                    };

                    subPathLines.push(newLine);
                };

                for (var i = 0; i < filesList.length; i++)
                {
                    handleLine(filesList[i]);
                }

                directoryLine.focus();
            };

            directoryLine.onentercommand = function()
            {
                listSubDirsAndFiles(directoryLine.text);
            };

            runCommandLine.onentercommand = function()
            {
                clearSubPathLines();

                var command = runCommandLine.text.substring(runCommandLine.text.indexOf(": ") + 2);
                var directory = getDirectory(directoryLine.text);

                runCommandLine.text = "%: ";

                var fullCommand = "";

                if (directory !== "")
                {
                    fullCommand = "cd " + directory + " && ";
                }

                fullCommand += command;

                var result = app.getCommandResult(fullCommand);
                result = "% " + fullCommand + "\n" + result;

                var handleLine = function(lineContent)
                {
                    var newLine = me.editControl.appendLine("| " + lineContent);
                    newLine.editable = false;

                    subPathLines.push(newLine);
                };

                var newLines = result.split("\n");

                for (var i = 0; i < newLines.length; i++)
                {
                    handleLine(newLines[i]);
                }

                runCommandLine.focus();
            };

            listSubDirsAndFiles(currentPath);

            submitLine.onentercommand = function()
            {
                me.saveDir = directoryLine.text + "";

                me.editControl.restoreState();

                selectingFile = false;

                if (onComplete)
                {
                    onComplete();
                }
            };
        }
        else if (window.app)
        {
            me.editControl.restoreState();

            selectingFile = false;
        }
    };

    this.toggleFindReplace = function(toFindInitial, replaceWithInitial, initialReplaceMode, displayResults)
    {
        if (!findReplaceEnabled)
        {
            var lines = me.editControl.getText().split("\n");

            me.editControl.saveState();

            me.editControl.setEditable(true);

            var editedLines = [];

            var replaceMode = initialReplaceMode || false;
            var toFind = toFindInitial || "", replaceWith = replaceWithInitial || "";

            var inputLine;

            var setUpInputs = function()
            {
                me.editControl.clear();

                var firstLine = me.editControl.appendLine(replaceMode ? "Replace With: " : "Find: ");
                firstLine.editable = false;

                inputLine = me.editControl.appendLine(replaceMode ? (replaceWith || "Replace Text Here") : (toFind || "RegExp Here"));

                inputLine.select();
                inputLine.focus();

                firstLine.onentercommand = function()
                {
                    if (!replaceMode)
                    {
                        firstLine.text = "Replace With:";

                        toFind = inputLine.text + "";

                        inputLine.text = replaceWith || "Replace Text Here";

                        requestAnimationFrame(() =>
                        {
                            inputLine.select();
                            inputLine.focus();

                            me.editControl.render();
                        });
                    }
                    else
                    {
                        replaceWith = inputLine.text + "";

                        firstLine.text = "Find: ";
                        inputLine.text = toFind || "RexExp Here";
                    }

                    replaceMode = !replaceMode;
                };
            };

            setUpInputs();

            inputLine.onentercommand = function(line)
            {
                // Clear all edited lines.
                for (var i = 0; i < editedLines.length; i++)
                {
                    editedLines[i].flaggedForRemoval = true;
                }

                me.editControl.removeLinesFlaggedForRemoval();
                editedLines = [];

                // Cache replacable text.
                if (!replaceMode)
                {
                    toFind = line.text;
                }
                else
                {
                    replaceWith = line.text;
                }

                var searchExp;
                var newLine, results, indicies, info, lastIndex, currentIndex;

                searchExp = new RegExp(toFind, "g");

                for (var i = 0; i < lines.length; i++)
                {
                    searchExp.lastIndex = 0;

                    indicies = [];
                    info = [];

                    lastIndex = -1;
                    currentIndex = 0;

                    while ((results = searchExp.exec(lines[i])) !== null && currentIndex !== lastIndex)
                    {
                        lastIndex = currentIndex;

                        indicies.push(searchExp.lastIndex);
                        info.push(results[0]);

                        currentIndex = searchExp.lastIndex;
                    }

                    if (indicies.length > 0)
                    {

                        newLine = me.editControl.appendLine(i + ": " + lines[i] + " (" + info.join(", ") + ")");

                        let index = i*1;
                        let firstOccurranceIndex = indicies[0];

                        newLine.editable = false;
                        newLine.onentercommand = function()
                        {
                          if (!replaceMode)
                          {
                              requestAnimationFrame(function()
                            {
                                me.toggleFindReplace();

                                var line = me.editControl.lines[index];
                                line.focus();
                                line.cursorPosition = firstOccurranceIndex;
                                me.editControl.shiftViewIfNecessary(index);
                                me.editControl.render();
                            });
                          }
                          else
                          {
                            requestAnimationFrame(function()
                            {
                              searchExp.lastIndex = 0;

                              me.toggleFindReplace();

                              var line = me.editControl.lines[index];
                              line.text = line.text.replace(searchExp, replaceWith);

                              me.toggleFindReplace(searchExp, replaceWith, true, true);

                              me.editControl.render();
                            });
                          }
                        };

                        editedLines.push(newLine);
                    }
                } // End for loop.

                // Allow every match to be replaced if in replace mode.
                if (replaceMode)
                {
                    newLine = me.editControl.appendLine("Replace All");

                    newLine.editable = false;

                    newLine.onentercommand = function()
                    {
                        requestAnimationFrame(() =>
                        {
                            me.toggleFindReplace();

                            var currentLine;

                            for (var i = 0; i < me.editControl.lines.length; i++)
                            {
                                currentLine = me.editControl.lines[i];

                                searchExp.lastIndex = 0;

                                currentLine.text = currentLine.text.replace(searchExp, replaceWith);
                            }

                            me.editControl.render();
                        });
                    };

                    editedLines.push(newLine);
                }
            };

            if (displayResults)
            {
                requestAnimationFrame(() =>
                {
                    inputLine.onentercommand(inputLine);

                    me.editControl.render();
                });
            }
        }
        else
        {
            me.editControl.restoreState();
        }

        findReplaceEnabled = !findReplaceEnabled;
    };

    me.clear = me.editControl.clear;
    me.displayContent = me.editControl.displayContent;

    me.keyCanvas.width = me.keyboard.maxX;
    me.keyCanvas.height = me.keyboard.maxY;

    me.editCanvas.width = window.innerWidth;//me.keyCanvas.width;
    me.editCanvas.height = window.innerHeight * 0.9 - me.keyCanvas.height;

    // If sharing a parent, make room for the keyboard.
    if (textViewerParentElement === keyboardParentElement)
    {
        me.editCanvas.style.height = "calc(90vh - " + me.keyCanvas.height + "px)";
    }
    else
    {
        me.editCanvas.style.height = "calc(100% - 5px)";
    }

    me.editCanvas.style.width = "calc(100% - 2px)";

    me.keyboard.render();

    me.editControl.render();

    textViewerParentElement.appendChild(me.editCanvas);
    keyboardParentElement.appendChild(me.keyCanvas);
    textExportParentElement.appendChild(me.copyPasteControl);
    runFrameParentElement.appendChild(me.runFrame);
}

</script>

    
    <!-- Main Content -->
        <script>
"use strict";

function noteError(e)
{
    var result = "ERROR:\n";

    for (var key in e)
    {
        result += "\nKEY: `" + key + "`: VALUE: `" + e[key] + "`";
    }

    result += "\ntoString(): " + e.toString();

    document.body.innerText = result;

    var errorHandleDiv = document.createElement("div");
    errorHandleDiv.style.border = "1px solid white";
    errorHandleDiv.style.borderRadius = "4px";
    errorHandleDiv.style.padding = "6px";

    var errorHandleInput = document.createElement("textarea");
    var submitButton = document.createElement("button");

    submitButton.innerHTML = "RUN";
    submitButton.style.width = "90vw";
    submitButton.style.textAlign = "center";

    submitButton.onclick = function(event)
    {
        errorHandleDiv.innerText += "\n" + (eval("(function(console, error) { return (() => " + errorHandleInput.value + ")(); })").call(window,
        {
            log: (message) =>
            {
                errorHandleDiv.innerText += "\n" + message;
            }
        }, e));
        errorHandleInput.value = "";

        errorHandleDiv.scrollTop = errorHandleDiv.scrollHeight;
    };

    errorHandleInput.style.width = "90vw";
    errorHandleInput.style.color = "#aaffaa";
    errorHandleInput.style.backgroundColor = "black";
    errorHandleInput.style.height = "50px";

    document.body.appendChild(errorHandleDiv);
    document.body.appendChild(errorHandleInput);
    document.body.appendChild(submitButton);
}


var editor;

function openFile(pathName)
{
    try
    {
        var content = app.getFileContent(pathName);

        editor.clear();
        editor.displayContent(content);
    }
    catch(e)
    {
        noteError(e);
    }
}

function getEditorSaveState()
{
    return editor.getPreUnloadSaveString();
}

function main()
{
    editor = new Editor(document.body);

    if (window.app && window.app.getRestoreString() && app.getRestoreString().length > 0)
    {
        let restore = app.getRestoreString();

        editor.loadFromSaveString(restore);
    }
}

try
{
    main();
}
catch(e)
{
    noteError(e);
}
            </script></body></html>
